// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: server

package server

import (
	"fmt"
	"reflect"
	"v.io/v23/context"
	"v.io/v23/i18n"
	"v.io/v23/security"
	"v.io/v23/vdl"
	"v.io/v23/vdlroot/signature"
	"v.io/v23/vdlroot/time"
	"v.io/v23/verror"
	"v.io/v23/vom"
	"v.io/v23/vtrace"
	"v.io/x/ref/services/wspr/internal/principal"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

type Context struct {
	Language string
}

func (Context) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.Context"`
}) {
}

func (m *Context) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Language")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := (m.Language == "")
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget3.FromString(string(m.Language), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Context) MakeVDLTarget() vdl.Target {
	return &ContextTarget{Value: m}
}

type ContextTarget struct {
	Value          *Context
	languageTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ContextTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Context)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ContextTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Language":
		t.languageTarget.Value = &t.Value.Language
		target, err := &t.languageTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.Context", name)
	}
}
func (t *ContextTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ContextTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *ContextTarget) FromZero(tt *vdl.Type) error {
	*t.Value = Context{}
	return nil
}

type SecurityCall struct {
	Method                string
	Suffix                string
	MethodTags            []*vom.RawBytes
	LocalBlessings        principal.BlessingsId
	LocalBlessingStrings  []string
	RemoteBlessings       principal.BlessingsId
	RemoteBlessingStrings []string
	LocalEndpoint         string
	RemoteEndpoint        string
}

func (SecurityCall) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.SecurityCall"`
}) {
}

func (m *SecurityCall) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Method")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := (m.Method == "")
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget3.FromString(string(m.Method), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Suffix")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var7 := (m.Suffix == "")
		if var7 {
			if err := fieldTarget6.FromZero(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget6.FromString(string(m.Suffix), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("MethodTags")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var10 bool
		if len(m.MethodTags) == 0 {
			var10 = true
		}
		if var10 {
			if err := fieldTarget9.FromZero(tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		} else {

			listTarget11, err := fieldTarget9.StartList(tt.NonOptional().Field(2).Type, len(m.MethodTags))
			if err != nil {
				return err
			}
			for i, elem13 := range m.MethodTags {
				elemTarget12, err := listTarget11.StartElem(i)
				if err != nil {
					return err
				}

				if elem13 == nil {
					if err := elemTarget12.FromZero(tt.NonOptional().Field(2).Type.Elem()); err != nil {
						return err
					}
				} else {
					if err := elem13.FillVDLTarget(elemTarget12, tt.NonOptional().Field(2).Type.Elem()); err != nil {
						return err
					}
				}
				if err := listTarget11.FinishElem(elemTarget12); err != nil {
					return err
				}
			}
			if err := fieldTarget9.FinishList(listTarget11); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("LocalBlessings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var16 := (m.LocalBlessings == principal.BlessingsId(0))
		if var16 {
			if err := fieldTarget15.FromZero(tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		} else {

			if err := m.LocalBlessings.FillVDLTarget(fieldTarget15, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("LocalBlessingStrings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var19 bool
		if len(m.LocalBlessingStrings) == 0 {
			var19 = true
		}
		if var19 {
			if err := fieldTarget18.FromZero(tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
		} else {

			listTarget20, err := fieldTarget18.StartList(tt.NonOptional().Field(4).Type, len(m.LocalBlessingStrings))
			if err != nil {
				return err
			}
			for i, elem22 := range m.LocalBlessingStrings {
				elemTarget21, err := listTarget20.StartElem(i)
				if err != nil {
					return err
				}
				if err := elemTarget21.FromString(string(elem22), tt.NonOptional().Field(4).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget20.FinishElem(elemTarget21); err != nil {
					return err
				}
			}
			if err := fieldTarget18.FinishList(listTarget20); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
			return err
		}
	}
	keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("RemoteBlessings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var25 := (m.RemoteBlessings == principal.BlessingsId(0))
		if var25 {
			if err := fieldTarget24.FromZero(tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
		} else {

			if err := m.RemoteBlessings.FillVDLTarget(fieldTarget24, tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
			return err
		}
	}
	keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("RemoteBlessingStrings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var28 bool
		if len(m.RemoteBlessingStrings) == 0 {
			var28 = true
		}
		if var28 {
			if err := fieldTarget27.FromZero(tt.NonOptional().Field(6).Type); err != nil {
				return err
			}
		} else {

			listTarget29, err := fieldTarget27.StartList(tt.NonOptional().Field(6).Type, len(m.RemoteBlessingStrings))
			if err != nil {
				return err
			}
			for i, elem31 := range m.RemoteBlessingStrings {
				elemTarget30, err := listTarget29.StartElem(i)
				if err != nil {
					return err
				}
				if err := elemTarget30.FromString(string(elem31), tt.NonOptional().Field(6).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget29.FinishElem(elemTarget30); err != nil {
					return err
				}
			}
			if err := fieldTarget27.FinishList(listTarget29); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
			return err
		}
	}
	keyTarget32, fieldTarget33, err := fieldsTarget1.StartField("LocalEndpoint")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var34 := (m.LocalEndpoint == "")
		if var34 {
			if err := fieldTarget33.FromZero(tt.NonOptional().Field(7).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget33.FromString(string(m.LocalEndpoint), tt.NonOptional().Field(7).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget32, fieldTarget33); err != nil {
			return err
		}
	}
	keyTarget35, fieldTarget36, err := fieldsTarget1.StartField("RemoteEndpoint")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var37 := (m.RemoteEndpoint == "")
		if var37 {
			if err := fieldTarget36.FromZero(tt.NonOptional().Field(8).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget36.FromString(string(m.RemoteEndpoint), tt.NonOptional().Field(8).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget35, fieldTarget36); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SecurityCall) MakeVDLTarget() vdl.Target {
	return &SecurityCallTarget{Value: m}
}

type SecurityCallTarget struct {
	Value                       *SecurityCall
	methodTarget                vdl.StringTarget
	suffixTarget                vdl.StringTarget
	methodTagsTarget            __VDLTarget1_list
	localBlessingsTarget        principal.BlessingsIdTarget
	localBlessingStringsTarget  vdl.StringSliceTarget
	remoteBlessingsTarget       principal.BlessingsIdTarget
	remoteBlessingStringsTarget vdl.StringSliceTarget
	localEndpointTarget         vdl.StringTarget
	remoteEndpointTarget        vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SecurityCallTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*SecurityCall)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *SecurityCallTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Method":
		t.methodTarget.Value = &t.Value.Method
		target, err := &t.methodTarget, error(nil)
		return nil, target, err
	case "Suffix":
		t.suffixTarget.Value = &t.Value.Suffix
		target, err := &t.suffixTarget, error(nil)
		return nil, target, err
	case "MethodTags":
		t.methodTagsTarget.Value = &t.Value.MethodTags
		target, err := &t.methodTagsTarget, error(nil)
		return nil, target, err
	case "LocalBlessings":
		t.localBlessingsTarget.Value = &t.Value.LocalBlessings
		target, err := &t.localBlessingsTarget, error(nil)
		return nil, target, err
	case "LocalBlessingStrings":
		t.localBlessingStringsTarget.Value = &t.Value.LocalBlessingStrings
		target, err := &t.localBlessingStringsTarget, error(nil)
		return nil, target, err
	case "RemoteBlessings":
		t.remoteBlessingsTarget.Value = &t.Value.RemoteBlessings
		target, err := &t.remoteBlessingsTarget, error(nil)
		return nil, target, err
	case "RemoteBlessingStrings":
		t.remoteBlessingStringsTarget.Value = &t.Value.RemoteBlessingStrings
		target, err := &t.remoteBlessingStringsTarget, error(nil)
		return nil, target, err
	case "LocalEndpoint":
		t.localEndpointTarget.Value = &t.Value.LocalEndpoint
		target, err := &t.localEndpointTarget, error(nil)
		return nil, target, err
	case "RemoteEndpoint":
		t.remoteEndpointTarget.Value = &t.Value.RemoteEndpoint
		target, err := &t.remoteEndpointTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.SecurityCall", name)
	}
}
func (t *SecurityCallTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SecurityCallTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *SecurityCallTarget) FromZero(tt *vdl.Type) error {
	*t.Value = SecurityCall{}
	return nil
}

// []*vom.RawBytes
type __VDLTarget1_list struct {
	Value *[]*vom.RawBytes

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]*vom.RawBytes)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vom.RawBytes, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}
func (t *__VDLTarget1_list) FromZero(tt *vdl.Type) error {
	*t.Value = []*vom.RawBytes(nil)
	return nil
}

type CaveatValidationRequest struct {
	Call    SecurityCall
	Context Context
	Cavs    [][]security.Caveat
}

func (CaveatValidationRequest) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.CaveatValidationRequest"`
}) {
}

func (m *CaveatValidationRequest) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Call")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := true
		var5 := (m.Call.Method == "")
		var4 = var4 && var5
		var6 := (m.Call.Suffix == "")
		var4 = var4 && var6
		var var7 bool
		if len(m.Call.MethodTags) == 0 {
			var7 = true
		}
		var4 = var4 && var7
		var8 := (m.Call.LocalBlessings == principal.BlessingsId(0))
		var4 = var4 && var8
		var var9 bool
		if len(m.Call.LocalBlessingStrings) == 0 {
			var9 = true
		}
		var4 = var4 && var9
		var10 := (m.Call.RemoteBlessings == principal.BlessingsId(0))
		var4 = var4 && var10
		var var11 bool
		if len(m.Call.RemoteBlessingStrings) == 0 {
			var11 = true
		}
		var4 = var4 && var11
		var12 := (m.Call.LocalEndpoint == "")
		var4 = var4 && var12
		var13 := (m.Call.RemoteEndpoint == "")
		var4 = var4 && var13
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {

			if err := m.Call.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("Context")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var16 := (m.Context == Context{})
		if var16 {
			if err := fieldTarget15.FromZero(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {

			if err := m.Context.FillVDLTarget(fieldTarget15, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("Cavs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var19 bool
		if len(m.Cavs) == 0 {
			var19 = true
		}
		if var19 {
			if err := fieldTarget18.FromZero(tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		} else {

			listTarget20, err := fieldTarget18.StartList(tt.NonOptional().Field(2).Type, len(m.Cavs))
			if err != nil {
				return err
			}
			for i, elem22 := range m.Cavs {
				elemTarget21, err := listTarget20.StartElem(i)
				if err != nil {
					return err
				}

				listTarget23, err := elemTarget21.StartList(tt.NonOptional().Field(2).Type.Elem(), len(elem22))
				if err != nil {
					return err
				}
				for i, elem25 := range elem22 {
					elemTarget24, err := listTarget23.StartElem(i)
					if err != nil {
						return err
					}

					if err := elem25.FillVDLTarget(elemTarget24, tt.NonOptional().Field(2).Type.Elem().Elem()); err != nil {
						return err
					}
					if err := listTarget23.FinishElem(elemTarget24); err != nil {
						return err
					}
				}
				if err := elemTarget21.FinishList(listTarget23); err != nil {
					return err
				}
				if err := listTarget20.FinishElem(elemTarget21); err != nil {
					return err
				}
			}
			if err := fieldTarget18.FinishList(listTarget20); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *CaveatValidationRequest) MakeVDLTarget() vdl.Target {
	return &CaveatValidationRequestTarget{Value: m}
}

type CaveatValidationRequestTarget struct {
	Value         *CaveatValidationRequest
	callTarget    SecurityCallTarget
	contextTarget ContextTarget
	cavsTarget    __VDLTarget2_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CaveatValidationRequestTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*CaveatValidationRequest)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CaveatValidationRequestTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Call":
		t.callTarget.Value = &t.Value.Call
		target, err := &t.callTarget, error(nil)
		return nil, target, err
	case "Context":
		t.contextTarget.Value = &t.Value.Context
		target, err := &t.contextTarget, error(nil)
		return nil, target, err
	case "Cavs":
		t.cavsTarget.Value = &t.Value.Cavs
		target, err := &t.cavsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.CaveatValidationRequest", name)
	}
}
func (t *CaveatValidationRequestTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CaveatValidationRequestTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *CaveatValidationRequestTarget) FromZero(tt *vdl.Type) error {
	*t.Value = CaveatValidationRequest{}
	return nil
}

// [][]security.Caveat
type __VDLTarget2_list struct {
	Value      *[][]security.Caveat
	elemTarget __VDLTarget3_list
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget2_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[][]security.Caveat)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([][]security.Caveat, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget2_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget2_list) FinishList(elem vdl.ListTarget) error {

	return nil
}
func (t *__VDLTarget2_list) FromZero(tt *vdl.Type) error {
	*t.Value = [][]security.Caveat(nil)
	return nil
}

// []security.Caveat
type __VDLTarget3_list struct {
	Value      *[]security.Caveat
	elemTarget security.CaveatTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget3_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]security.Caveat)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]security.Caveat, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget3_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget3_list) FinishList(elem vdl.ListTarget) error {

	return nil
}
func (t *__VDLTarget3_list) FromZero(tt *vdl.Type) error {
	*t.Value = []security.Caveat(nil)
	return nil
}

type CaveatValidationResponse struct {
	Results []error
}

func (CaveatValidationResponse) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.CaveatValidationResponse"`
}) {
}

func (m *CaveatValidationResponse) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Results")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var4 bool
		if len(m.Results) == 0 {
			var4 = true
		}
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {

			listTarget5, err := fieldTarget3.StartList(tt.NonOptional().Field(0).Type, len(m.Results))
			if err != nil {
				return err
			}
			for i, elem7 := range m.Results {
				elemTarget6, err := listTarget5.StartElem(i)
				if err != nil {
					return err
				}

				var wireError8 vdl.WireError
				if err := verror.WireFromNative(&wireError8, elem7); err != nil {
					return err
				}
				if err := wireError8.FillVDLTarget(elemTarget6, vdl.ErrorType); err != nil {
					return err
				}

				if err := listTarget5.FinishElem(elemTarget6); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishList(listTarget5); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *CaveatValidationResponse) MakeVDLTarget() vdl.Target {
	return &CaveatValidationResponseTarget{Value: m}
}

type CaveatValidationResponseTarget struct {
	Value         *CaveatValidationResponse
	resultsTarget __VDLTarget4_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CaveatValidationResponseTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*CaveatValidationResponse)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CaveatValidationResponseTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Results":
		t.resultsTarget.Value = &t.Value.Results
		target, err := &t.resultsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.CaveatValidationResponse", name)
	}
}
func (t *CaveatValidationResponseTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CaveatValidationResponseTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *CaveatValidationResponseTarget) FromZero(tt *vdl.Type) error {
	*t.Value = CaveatValidationResponse{}
	return nil
}

// []error
type __VDLTarget4_list struct {
	Value      *[]error
	elemTarget verror.ErrorTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget4_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]error)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]error, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget4_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget4_list) FinishList(elem vdl.ListTarget) error {

	return nil
}
func (t *__VDLTarget4_list) FromZero(tt *vdl.Type) error {
	*t.Value = []error(nil)
	return nil
}

type ServerRpcRequestCall struct {
	SecurityCall     SecurityCall
	Deadline         time.Deadline
	Context          Context
	TraceRequest     vtrace.Request
	GrantedBlessings principal.BlessingsId
}

func (ServerRpcRequestCall) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.ServerRpcRequestCall"`
}) {
}

func (m *ServerRpcRequestCall) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("SecurityCall")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := true
		var5 := (m.SecurityCall.Method == "")
		var4 = var4 && var5
		var6 := (m.SecurityCall.Suffix == "")
		var4 = var4 && var6
		var var7 bool
		if len(m.SecurityCall.MethodTags) == 0 {
			var7 = true
		}
		var4 = var4 && var7
		var8 := (m.SecurityCall.LocalBlessings == principal.BlessingsId(0))
		var4 = var4 && var8
		var var9 bool
		if len(m.SecurityCall.LocalBlessingStrings) == 0 {
			var9 = true
		}
		var4 = var4 && var9
		var10 := (m.SecurityCall.RemoteBlessings == principal.BlessingsId(0))
		var4 = var4 && var10
		var var11 bool
		if len(m.SecurityCall.RemoteBlessingStrings) == 0 {
			var11 = true
		}
		var4 = var4 && var11
		var12 := (m.SecurityCall.LocalEndpoint == "")
		var4 = var4 && var12
		var13 := (m.SecurityCall.RemoteEndpoint == "")
		var4 = var4 && var13
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {

			if err := m.SecurityCall.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	var wireValue14 time.WireDeadline
	if err := time.WireDeadlineFromNative(&wireValue14, m.Deadline); err != nil {
		return err
	}

	keyTarget15, fieldTarget16, err := fieldsTarget1.StartField("Deadline")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var17 := (wireValue14 == time.WireDeadline{})
		if var17 {
			if err := fieldTarget16.FromZero(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {

			if err := wireValue14.FillVDLTarget(fieldTarget16, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget15, fieldTarget16); err != nil {
			return err
		}
	}
	keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("Context")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var20 := (m.Context == Context{})
		if var20 {
			if err := fieldTarget19.FromZero(tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		} else {

			if err := m.Context.FillVDLTarget(fieldTarget19, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
			return err
		}
	}
	keyTarget21, fieldTarget22, err := fieldsTarget1.StartField("TraceRequest")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var23 := (m.TraceRequest == vtrace.Request{})
		if var23 {
			if err := fieldTarget22.FromZero(tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		} else {

			if err := m.TraceRequest.FillVDLTarget(fieldTarget22, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget21, fieldTarget22); err != nil {
			return err
		}
	}
	keyTarget24, fieldTarget25, err := fieldsTarget1.StartField("GrantedBlessings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var26 := (m.GrantedBlessings == principal.BlessingsId(0))
		if var26 {
			if err := fieldTarget25.FromZero(tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
		} else {

			if err := m.GrantedBlessings.FillVDLTarget(fieldTarget25, tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget24, fieldTarget25); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ServerRpcRequestCall) MakeVDLTarget() vdl.Target {
	return &ServerRpcRequestCallTarget{Value: m}
}

type ServerRpcRequestCallTarget struct {
	Value                  *ServerRpcRequestCall
	securityCallTarget     SecurityCallTarget
	deadlineTarget         time.WireDeadlineTarget
	contextTarget          ContextTarget
	traceRequestTarget     vtrace.RequestTarget
	grantedBlessingsTarget principal.BlessingsIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ServerRpcRequestCallTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ServerRpcRequestCall)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ServerRpcRequestCallTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "SecurityCall":
		t.securityCallTarget.Value = &t.Value.SecurityCall
		target, err := &t.securityCallTarget, error(nil)
		return nil, target, err
	case "Deadline":
		t.deadlineTarget.Value = &t.Value.Deadline
		target, err := &t.deadlineTarget, error(nil)
		return nil, target, err
	case "Context":
		t.contextTarget.Value = &t.Value.Context
		target, err := &t.contextTarget, error(nil)
		return nil, target, err
	case "TraceRequest":
		t.traceRequestTarget.Value = &t.Value.TraceRequest
		target, err := &t.traceRequestTarget, error(nil)
		return nil, target, err
	case "GrantedBlessings":
		t.grantedBlessingsTarget.Value = &t.Value.GrantedBlessings
		target, err := &t.grantedBlessingsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.ServerRpcRequestCall", name)
	}
}
func (t *ServerRpcRequestCallTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ServerRpcRequestCallTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *ServerRpcRequestCallTarget) FromZero(tt *vdl.Type) error {
	*t.Value = ServerRpcRequestCall{}
	return nil
}

// A request from the proxy to javascript to handle an RPC
type ServerRpcRequest struct {
	ServerId uint32
	Handle   int32
	Method   string
	Args     []*vom.RawBytes
	Call     ServerRpcRequestCall
}

func (ServerRpcRequest) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.ServerRpcRequest"`
}) {
}

func (m *ServerRpcRequest) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ServerId")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := (m.ServerId == uint32(0))
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget3.FromUint(uint64(m.ServerId), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Handle")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var7 := (m.Handle == int32(0))
		if var7 {
			if err := fieldTarget6.FromZero(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget6.FromInt(int64(m.Handle), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Method")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var10 := (m.Method == "")
		if var10 {
			if err := fieldTarget9.FromZero(tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget9.FromString(string(m.Method), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Args")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var13 bool
		if len(m.Args) == 0 {
			var13 = true
		}
		if var13 {
			if err := fieldTarget12.FromZero(tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		} else {

			listTarget14, err := fieldTarget12.StartList(tt.NonOptional().Field(3).Type, len(m.Args))
			if err != nil {
				return err
			}
			for i, elem16 := range m.Args {
				elemTarget15, err := listTarget14.StartElem(i)
				if err != nil {
					return err
				}

				if elem16 == nil {
					if err := elemTarget15.FromZero(tt.NonOptional().Field(3).Type.Elem()); err != nil {
						return err
					}
				} else {
					if err := elem16.FillVDLTarget(elemTarget15, tt.NonOptional().Field(3).Type.Elem()); err != nil {
						return err
					}
				}
				if err := listTarget14.FinishElem(elemTarget15); err != nil {
					return err
				}
			}
			if err := fieldTarget12.FinishList(listTarget14); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("Call")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var19 := true
		var20 := true
		var21 := (m.Call.SecurityCall.Method == "")
		var20 = var20 && var21
		var22 := (m.Call.SecurityCall.Suffix == "")
		var20 = var20 && var22
		var var23 bool
		if len(m.Call.SecurityCall.MethodTags) == 0 {
			var23 = true
		}
		var20 = var20 && var23
		var24 := (m.Call.SecurityCall.LocalBlessings == principal.BlessingsId(0))
		var20 = var20 && var24
		var var25 bool
		if len(m.Call.SecurityCall.LocalBlessingStrings) == 0 {
			var25 = true
		}
		var20 = var20 && var25
		var26 := (m.Call.SecurityCall.RemoteBlessings == principal.BlessingsId(0))
		var20 = var20 && var26
		var var27 bool
		if len(m.Call.SecurityCall.RemoteBlessingStrings) == 0 {
			var27 = true
		}
		var20 = var20 && var27
		var28 := (m.Call.SecurityCall.LocalEndpoint == "")
		var20 = var20 && var28
		var29 := (m.Call.SecurityCall.RemoteEndpoint == "")
		var20 = var20 && var29
		var19 = var19 && var20
		var wireValue30 time.WireDeadline
		if err := time.WireDeadlineFromNative(&wireValue30, m.Call.Deadline); err != nil {
			return fmt.Errorf("error converting m.Call.Deadline to wiretype")
		}

		var31 := (wireValue30 == time.WireDeadline{})
		var19 = var19 && var31
		var32 := (m.Call.Context == Context{})
		var19 = var19 && var32
		var33 := (m.Call.TraceRequest == vtrace.Request{})
		var19 = var19 && var33
		var34 := (m.Call.GrantedBlessings == principal.BlessingsId(0))
		var19 = var19 && var34
		if var19 {
			if err := fieldTarget18.FromZero(tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
		} else {

			if err := m.Call.FillVDLTarget(fieldTarget18, tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ServerRpcRequest) MakeVDLTarget() vdl.Target {
	return &ServerRpcRequestTarget{Value: m}
}

type ServerRpcRequestTarget struct {
	Value          *ServerRpcRequest
	serverIdTarget vdl.Uint32Target
	handleTarget   vdl.Int32Target
	methodTarget   vdl.StringTarget
	argsTarget     __VDLTarget1_list
	callTarget     ServerRpcRequestCallTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ServerRpcRequestTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ServerRpcRequest)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ServerRpcRequestTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ServerId":
		t.serverIdTarget.Value = &t.Value.ServerId
		target, err := &t.serverIdTarget, error(nil)
		return nil, target, err
	case "Handle":
		t.handleTarget.Value = &t.Value.Handle
		target, err := &t.handleTarget, error(nil)
		return nil, target, err
	case "Method":
		t.methodTarget.Value = &t.Value.Method
		target, err := &t.methodTarget, error(nil)
		return nil, target, err
	case "Args":
		t.argsTarget.Value = &t.Value.Args
		target, err := &t.argsTarget, error(nil)
		return nil, target, err
	case "Call":
		t.callTarget.Value = &t.Value.Call
		target, err := &t.callTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.ServerRpcRequest", name)
	}
}
func (t *ServerRpcRequestTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ServerRpcRequestTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *ServerRpcRequestTarget) FromZero(tt *vdl.Type) error {
	*t.Value = ServerRpcRequest{}
	return nil
}

// A reply from javascript to a lookup request.
type LookupReply struct {
	Handle        int32
	HasAuthorizer bool
	HasGlobber    bool
	Signature     []signature.Interface
	Err           error
}

func (LookupReply) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.LookupReply"`
}) {
}

func (m *LookupReply) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Handle")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := (m.Handle == int32(0))
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget3.FromInt(int64(m.Handle), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("HasAuthorizer")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var7 := (m.HasAuthorizer == false)
		if var7 {
			if err := fieldTarget6.FromZero(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget6.FromBool(bool(m.HasAuthorizer), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("HasGlobber")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var10 := (m.HasGlobber == false)
		if var10 {
			if err := fieldTarget9.FromZero(tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget9.FromBool(bool(m.HasGlobber), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Signature")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var13 bool
		if len(m.Signature) == 0 {
			var13 = true
		}
		if var13 {
			if err := fieldTarget12.FromZero(tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		} else {

			listTarget14, err := fieldTarget12.StartList(tt.NonOptional().Field(3).Type, len(m.Signature))
			if err != nil {
				return err
			}
			for i, elem16 := range m.Signature {
				elemTarget15, err := listTarget14.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem16.FillVDLTarget(elemTarget15, tt.NonOptional().Field(3).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget14.FinishElem(elemTarget15); err != nil {
					return err
				}
			}
			if err := fieldTarget12.FinishList(listTarget14); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("Err")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var19 := (m.Err == (error)(nil))
		if var19 {
			if err := fieldTarget18.FromZero(tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
		} else {

			var wireError20 vdl.WireError
			if err := verror.WireFromNative(&wireError20, m.Err); err != nil {
				return err
			}
			if err := wireError20.FillVDLTarget(fieldTarget18, vdl.ErrorType); err != nil {
				return err
			}

		}
		if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LookupReply) MakeVDLTarget() vdl.Target {
	return &LookupReplyTarget{Value: m}
}

type LookupReplyTarget struct {
	Value               *LookupReply
	handleTarget        vdl.Int32Target
	hasAuthorizerTarget vdl.BoolTarget
	hasGlobberTarget    vdl.BoolTarget
	signatureTarget     __VDLTarget5_list
	errTarget           verror.ErrorTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LookupReplyTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LookupReply)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LookupReplyTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Handle":
		t.handleTarget.Value = &t.Value.Handle
		target, err := &t.handleTarget, error(nil)
		return nil, target, err
	case "HasAuthorizer":
		t.hasAuthorizerTarget.Value = &t.Value.HasAuthorizer
		target, err := &t.hasAuthorizerTarget, error(nil)
		return nil, target, err
	case "HasGlobber":
		t.hasGlobberTarget.Value = &t.Value.HasGlobber
		target, err := &t.hasGlobberTarget, error(nil)
		return nil, target, err
	case "Signature":
		t.signatureTarget.Value = &t.Value.Signature
		target, err := &t.signatureTarget, error(nil)
		return nil, target, err
	case "Err":
		t.errTarget.Value = &t.Value.Err
		target, err := &t.errTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.LookupReply", name)
	}
}
func (t *LookupReplyTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LookupReplyTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *LookupReplyTarget) FromZero(tt *vdl.Type) error {
	*t.Value = LookupReply{}
	return nil
}

// []signature.Interface
type __VDLTarget5_list struct {
	Value      *[]signature.Interface
	elemTarget signature.InterfaceTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget5_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]signature.Interface)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]signature.Interface, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget5_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget5_list) FinishList(elem vdl.ListTarget) error {

	return nil
}
func (t *__VDLTarget5_list) FromZero(tt *vdl.Type) error {
	*t.Value = []signature.Interface(nil)
	return nil
}

// A reply from javascript to an auth request.
type AuthReply struct {
	Err error
}

func (AuthReply) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.AuthReply"`
}) {
}

func (m *AuthReply) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Err")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := (m.Err == (error)(nil))
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {

			var wireError5 vdl.WireError
			if err := verror.WireFromNative(&wireError5, m.Err); err != nil {
				return err
			}
			if err := wireError5.FillVDLTarget(fieldTarget3, vdl.ErrorType); err != nil {
				return err
			}

		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AuthReply) MakeVDLTarget() vdl.Target {
	return &AuthReplyTarget{Value: m}
}

type AuthReplyTarget struct {
	Value     *AuthReply
	errTarget verror.ErrorTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AuthReplyTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*AuthReply)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *AuthReplyTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Err":
		t.errTarget.Value = &t.Value.Err
		target, err := &t.errTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.AuthReply", name)
	}
}
func (t *AuthReplyTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AuthReplyTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *AuthReplyTarget) FromZero(tt *vdl.Type) error {
	*t.Value = AuthReply{}
	return nil
}

//////////////////////////////////////////////////
// Error definitions
var (
	ErrCaveatValidationTimeout                 = verror.Register("v.io/x/ref/services/wspr/internal/rpc/server.CaveatValidationTimeout", verror.NoRetry, "{1:}{2:} Caveat validation has timed out")
	ErrInvalidValidationResponseFromJavascript = verror.Register("v.io/x/ref/services/wspr/internal/rpc/server.InvalidValidationResponseFromJavascript", verror.NoRetry, "{1:}{2:} Invalid validation response from javascript")
	ErrServerStopped                           = verror.Register("v.io/x/ref/services/wspr/internal/rpc/server.ServerStopped", verror.RetryBackoff, "{1:}{2:} Server has been stopped")
)

// NewErrCaveatValidationTimeout returns an error with the ErrCaveatValidationTimeout ID.
func NewErrCaveatValidationTimeout(ctx *context.T) error {
	return verror.New(ErrCaveatValidationTimeout, ctx)
}

// NewErrInvalidValidationResponseFromJavascript returns an error with the ErrInvalidValidationResponseFromJavascript ID.
func NewErrInvalidValidationResponseFromJavascript(ctx *context.T) error {
	return verror.New(ErrInvalidValidationResponseFromJavascript, ctx)
}

// NewErrServerStopped returns an error with the ErrServerStopped ID.
func NewErrServerStopped(ctx *context.T) error {
	return verror.New(ErrServerStopped, ctx)
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*Context)(nil))
	vdl.Register((*SecurityCall)(nil))
	vdl.Register((*CaveatValidationRequest)(nil))
	vdl.Register((*CaveatValidationResponse)(nil))
	vdl.Register((*ServerRpcRequestCall)(nil))
	vdl.Register((*ServerRpcRequest)(nil))
	vdl.Register((*LookupReply)(nil))
	vdl.Register((*AuthReply)(nil))

	// Set error format strings.
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatValidationTimeout.ID), "{1:}{2:} Caveat validation has timed out")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrInvalidValidationResponseFromJavascript.ID), "{1:}{2:} Invalid validation response from javascript")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrServerStopped.ID), "{1:}{2:} Server has been stopped")

	return struct{}{}
}
