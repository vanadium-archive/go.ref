// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: lib

package lib

import (
	"fmt"
	"reflect"
	"v.io/v23/vdl"
	"v.io/v23/verror"
	"v.io/v23/vom"
	"v.io/v23/vtrace"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// The response from the javascript server to the proxy.
type ServerRpcReply struct {
	Results       []*vom.RawBytes
	Err           error
	TraceResponse vtrace.Response
}

func (ServerRpcReply) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/lib.ServerRpcReply"`
}) {
}

func (m *ServerRpcReply) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Results")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget4, err := fieldTarget3.StartList(tt.NonOptional().Field(0).Type, len(m.Results))
		if err != nil {
			return err
		}
		for i, elem6 := range m.Results {
			elemTarget5, err := listTarget4.StartElem(i)
			if err != nil {
				return err
			}

			if elem6 == nil {
				if err := elemTarget5.FromNil(tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
			} else {
				if err := elem6.FillVDLTarget(elemTarget5, tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
			}
			if err := listTarget4.FinishElem(elemTarget5); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishList(listTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("Err")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Err == nil {
			if err := fieldTarget8.FromNil(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {
			var wireError9 vdl.WireError
			if err := verror.WireFromNative(&wireError9, m.Err); err != nil {
				return err
			}
			if err := wireError9.FillVDLTarget(fieldTarget8, vdl.ErrorType); err != nil {
				return err
			}

		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("TraceResponse")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.TraceResponse.FillVDLTarget(fieldTarget11, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ServerRpcReply) MakeVDLTarget() vdl.Target {
	return &ServerRpcReplyTarget{Value: m}
}

type ServerRpcReplyTarget struct {
	Value               *ServerRpcReply
	resultsTarget       unnamed_5b5d616e79Target
	errTarget           verror.ErrorTarget
	traceResponseTarget vtrace.ResponseTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ServerRpcReplyTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ServerRpcReply)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ServerRpcReplyTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Results":
		t.resultsTarget.Value = &t.Value.Results
		target, err := &t.resultsTarget, error(nil)
		return nil, target, err
	case "Err":
		t.errTarget.Value = &t.Value.Err
		target, err := &t.errTarget, error(nil)
		return nil, target, err
	case "TraceResponse":
		t.traceResponseTarget.Value = &t.Value.TraceResponse
		target, err := &t.traceResponseTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/lib.ServerRpcReply", name)
	}
}
func (t *ServerRpcReplyTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ServerRpcReplyTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []*vom.RawBytes
type unnamed_5b5d616e79Target struct {
	Value *[]*vom.RawBytes

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *unnamed_5b5d616e79Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]*vom.RawBytes)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vom.RawBytes, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *unnamed_5b5d616e79Target) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
	return target, err
}
func (t *unnamed_5b5d616e79Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *unnamed_5b5d616e79Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type LogLevel int

const (
	LogLevelInfo LogLevel = iota
	LogLevelError
)

// LogLevelAll holds all labels for LogLevel.
var LogLevelAll = [...]LogLevel{LogLevelInfo, LogLevelError}

// LogLevelFromString creates a LogLevel from a string label.
func LogLevelFromString(label string) (x LogLevel, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *LogLevel) Set(label string) error {
	switch label {
	case "Info", "info":
		*x = LogLevelInfo
		return nil
	case "Error", "error":
		*x = LogLevelError
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in lib.LogLevel", label)
}

// String returns the string label of x.
func (x LogLevel) String() string {
	switch x {
	case LogLevelInfo:
		return "Info"
	case LogLevelError:
		return "Error"
	}
	return ""
}

func (LogLevel) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/lib.LogLevel"`
	Enum struct{ Info, Error string }
}) {
}

func (m *LogLevel) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *LogLevel) MakeVDLTarget() vdl.Target {
	return &LogLevelTarget{Value: m}
}

type LogLevelTarget struct {
	Value *LogLevel
	vdl.TargetBase
}

func (t *LogLevelTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*LogLevel)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Info":
		*t.Value = 0
	case "Error":
		*t.Value = 1
	default:
		return fmt.Errorf("label %s not in enum v.io/x/ref/services/wspr/internal/lib.LogLevel", src)
	}

	return nil
}

type LogMessage struct {
	Level   LogLevel
	Message string
}

func (LogMessage) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/lib.LogMessage"`
}) {
}

func (m *LogMessage) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Level")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Level.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Message")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.Message), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LogMessage) MakeVDLTarget() vdl.Target {
	return &LogMessageTarget{Value: m}
}

type LogMessageTarget struct {
	Value         *LogMessage
	levelTarget   LogLevelTarget
	messageTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LogMessageTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LogMessage)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LogMessageTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Level":
		t.levelTarget.Value = &t.Value.Level
		target, err := &t.levelTarget, error(nil)
		return nil, target, err
	case "Message":
		t.messageTarget.Value = &t.Value.Message
		target, err := &t.messageTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/lib.LogMessage", name)
	}
}
func (t *LogMessageTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LogMessageTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}

	// Register types.
	vdl.Register((*ServerRpcReply)(nil))
	vdl.Register((*LogLevel)(nil))
	vdl.Register((*LogMessage)(nil))

	return struct{}{}
}
