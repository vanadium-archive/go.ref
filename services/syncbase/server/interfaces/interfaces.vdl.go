// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: interfaces

package interfaces

import (
	"fmt"
	"io"
	"reflect"
	"time"
	"v.io/v23"
	"v.io/v23/context"
	"v.io/v23/i18n"
	"v.io/v23/rpc"
	"v.io/v23/security/access"
	"v.io/v23/services/syncbase/nosql"
	"v.io/v23/vdl"
	"v.io/v23/vdl/vdlconv"
	time_2 "v.io/v23/vdlroot/time"
	"v.io/v23/verror"
)

// GenVector is the generation vector for any syncable entity, which maps each
// device id to its last locally known generation in the scope of that entity.
type GenVector map[uint64]uint64

func (GenVector) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.GenVector"`
}) {
}

func (m *GenVector) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_GenVector, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), vdl.Uint64Type); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromUint(uint64(value5), vdl.Uint64Type); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *GenVector) MakeVDLTarget() vdl.Target {
	return &GenVectorTarget{Value: m}
}

type GenVectorTarget struct {
	Value      *GenVector
	currKey    uint64
	currElem   uint64
	keyTarget  vdl.Uint64Target
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *GenVectorTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GenVector) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GenVector)
	}
	*t.Value = make(GenVector)
	return t, nil
}
func (t *GenVectorTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *GenVectorTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = uint64(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *GenVectorTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *GenVectorTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// Knowledge is a mapping of syncable entities to their generation
// vectors. These syncable entities could be data prefixes relative to an
// Application and Database name, or syncgroup oids.
type Knowledge map[string]GenVector

func (Knowledge) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.Knowledge"`
}) {
}

func (m *Knowledge) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_Knowledge, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), vdl.StringType); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GenVector); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Knowledge) MakeVDLTarget() vdl.Target {
	return &KnowledgeTarget{Value: m}
}

type KnowledgeTarget struct {
	Value      *Knowledge
	currKey    string
	currElem   GenVector
	keyTarget  vdl.StringTarget
	elemTarget GenVectorTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *KnowledgeTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Knowledge) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Knowledge)
	}
	*t.Value = make(Knowledge)
	return t, nil
}
func (t *KnowledgeTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *KnowledgeTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = GenVector(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *KnowledgeTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *KnowledgeTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// LogRecMetadata represents the metadata of a single log record that is
// exchanged between two peers. Each log record represents a change made to an
// object in the store.
//
// TODO(hpucha): Add readset/scanset. Look into sending tx metadata only once
// per transaction.
type LogRecMetadata struct {
	// Log related information.
	Id      uint64 // device id that created the log record.
	Gen     uint64 // generation number for the log record.
	RecType byte   // type of log record.
	// Id of the object that was updated. This id is relative to Application
	// and Database names and is the store key for a particular row in a
	// table.
	ObjId      string
	CurVers    string    // current version number of the object.
	Parents    []string  // 0, 1 or 2 parent versions that the current version is derived from.
	UpdTime    time.Time // timestamp when the update is generated.
	PermId     string    // id of the permissions object controlling this version.
	PermVers   string    // current version of the permissions object.
	Delete     bool      // indicates whether the update resulted in object being deleted from the store.
	BatchId    uint64    // unique id of the Batch this update belongs to.
	BatchCount uint64    // number of objects in the Batch.
}

func (LogRecMetadata) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata"`
}) {
}

func (m *LogRecMetadata) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	__VDLEnsureNativeBuilt()
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Id")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromUint(uint64(m.Id), vdl.Uint64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Gen")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromUint(uint64(m.Gen), vdl.Uint64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("RecType")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromUint(uint64(m.RecType), vdl.ByteType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("ObjId")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget9.FromString(string(m.ObjId), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("CurVers")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget11.FromString(string(m.CurVers), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("Parents")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget14, err := fieldTarget13.StartList(__VDLType1, len(m.Parents))
		if err != nil {
			return err
		}
		for i, elem16 := range m.Parents {
			elemTarget15, err := listTarget14.StartElem(i)
			if err != nil {
				return err
			}
			if err := elemTarget15.FromString(string(elem16), vdl.StringType); err != nil {
				return err
			}
			if err := listTarget14.FinishElem(elemTarget15); err != nil {
				return err
			}
		}
		if err := fieldTarget13.FinishList(listTarget14); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	var wireValue17 time_2.Time
	if err := time_2.TimeFromNative(&wireValue17, m.UpdTime); err != nil {
		return err
	}

	keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("UpdTime")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue17.FillVDLTarget(fieldTarget19, __VDLType_time_Time); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
			return err
		}
	}
	keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("PermId")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget21.FromString(string(m.PermId), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
			return err
		}
	}
	keyTarget22, fieldTarget23, err := fieldsTarget1.StartField("PermVers")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget23.FromString(string(m.PermVers), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget22, fieldTarget23); err != nil {
			return err
		}
	}
	keyTarget24, fieldTarget25, err := fieldsTarget1.StartField("Delete")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget25.FromBool(bool(m.Delete), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget24, fieldTarget25); err != nil {
			return err
		}
	}
	keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("BatchId")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget27.FromUint(uint64(m.BatchId), vdl.Uint64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
			return err
		}
	}
	keyTarget28, fieldTarget29, err := fieldsTarget1.StartField("BatchCount")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget29.FromUint(uint64(m.BatchCount), vdl.Uint64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget28, fieldTarget29); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LogRecMetadata) MakeVDLTarget() vdl.Target {
	return &LogRecMetadataTarget{Value: m}
}

type LogRecMetadataTarget struct {
	Value            *LogRecMetadata
	idTarget         vdl.Uint64Target
	genTarget        vdl.Uint64Target
	recTypeTarget    vdl.ByteTarget
	objIdTarget      vdl.StringTarget
	curVersTarget    vdl.StringTarget
	parentsTarget    vdl.StringSliceTarget
	updTimeTarget    time_2.TimeTarget
	permIdTarget     vdl.StringTarget
	permVersTarget   vdl.StringTarget
	deleteTarget     vdl.BoolTarget
	batchIdTarget    vdl.Uint64Target
	batchCountTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LogRecMetadataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata)
	}
	return t, nil
}
func (t *LogRecMetadataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Id":
		t.idTarget.Value = &t.Value.Id
		target, err := &t.idTarget, error(nil)
		return nil, target, err
	case "Gen":
		t.genTarget.Value = &t.Value.Gen
		target, err := &t.genTarget, error(nil)
		return nil, target, err
	case "RecType":
		t.recTypeTarget.Value = &t.Value.RecType
		target, err := &t.recTypeTarget, error(nil)
		return nil, target, err
	case "ObjId":
		t.objIdTarget.Value = &t.Value.ObjId
		target, err := &t.objIdTarget, error(nil)
		return nil, target, err
	case "CurVers":
		t.curVersTarget.Value = &t.Value.CurVers
		target, err := &t.curVersTarget, error(nil)
		return nil, target, err
	case "Parents":
		t.parentsTarget.Value = &t.Value.Parents
		target, err := &t.parentsTarget, error(nil)
		return nil, target, err
	case "UpdTime":
		t.updTimeTarget.Value = &t.Value.UpdTime
		target, err := &t.updTimeTarget, error(nil)
		return nil, target, err
	case "PermId":
		t.permIdTarget.Value = &t.Value.PermId
		target, err := &t.permIdTarget, error(nil)
		return nil, target, err
	case "PermVers":
		t.permVersTarget.Value = &t.Value.PermVers
		target, err := &t.permVersTarget, error(nil)
		return nil, target, err
	case "Delete":
		t.deleteTarget.Value = &t.Value.Delete
		target, err := &t.deleteTarget, error(nil)
		return nil, target, err
	case "BatchId":
		t.batchIdTarget.Value = &t.Value.BatchId
		target, err := &t.batchIdTarget, error(nil)
		return nil, target, err
	case "BatchCount":
		t.batchCountTarget.Value = &t.Value.BatchCount
		target, err := &t.batchCountTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata)
	}
}
func (t *LogRecMetadataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LogRecMetadataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// LogRec represents the on-wire representation of an entire log record: its
// metadata and data. Value is the actual value of a store object.
type LogRec struct {
	Metadata LogRecMetadata
	Value    []byte
	Shell    bool // true when the mutation data is hidden due to permissions.
}

func (LogRec) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.LogRec"`
}) {
}

func (m *LogRec) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	__VDLEnsureNativeBuilt()
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Metadata")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Metadata.FillVDLTarget(fieldTarget3, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Value")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := fieldTarget5.FromBytes([]byte(m.Value), __VDLType3); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Shell")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromBool(bool(m.Shell), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LogRec) MakeVDLTarget() vdl.Target {
	return &LogRecTarget{Value: m}
}

type LogRecTarget struct {
	Value          *LogRec
	metadataTarget LogRecMetadataTarget
	valueTarget    vdl.BytesTarget
	shellTarget    vdl.BoolTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LogRecTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec)
	}
	return t, nil
}
func (t *LogRecTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Metadata":
		t.metadataTarget.Value = &t.Value.Metadata
		target, err := &t.metadataTarget, error(nil)
		return nil, target, err
	case "Value":
		t.valueTarget.Value = &t.Value.Value
		target, err := &t.valueTarget, error(nil)
		return nil, target, err
	case "Shell":
		t.shellTarget.Value = &t.Value.Shell
		target, err := &t.shellTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec)
	}
}
func (t *LogRecTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LogRecTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// GroupId is a globally unique syncgroup ID.
// TODO(hpucha): Make this a string since now the syncgroup id is an object id.
type GroupId uint64

func (GroupId) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.GroupId"`
}) {
}

func (m *GroupId) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GroupId); err != nil {
		return err
	}
	return nil
}

func (m *GroupId) MakeVDLTarget() vdl.Target {
	return &GroupIdTarget{Value: m}
}

type GroupIdTarget struct {
	Value *GroupId
	vdl.TargetBase
}

func (t *GroupIdTarget) FromUint(src uint64, tt *vdl.Type) error {

	*t.Value = GroupId(src)

	return nil
}
func (t *GroupIdTarget) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = GroupId(val)

	return nil
}
func (t *GroupIdTarget) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = GroupId(val)

	return nil
}
func (t *GroupIdTarget) FromComplex(src complex128, tt *vdl.Type) error {

	val, err := vdlconv.Complex128ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = GroupId(val)

	return nil
}

// Possible states for a syncgroup.
type SyncgroupStatus int

const (
	SyncgroupStatusPublishPending SyncgroupStatus = iota
	SyncgroupStatusPublishRejected
	SyncgroupStatusRunning
)

// SyncgroupStatusAll holds all labels for SyncgroupStatus.
var SyncgroupStatusAll = [...]SyncgroupStatus{SyncgroupStatusPublishPending, SyncgroupStatusPublishRejected, SyncgroupStatusRunning}

// SyncgroupStatusFromString creates a SyncgroupStatus from a string label.
func SyncgroupStatusFromString(label string) (x SyncgroupStatus, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *SyncgroupStatus) Set(label string) error {
	switch label {
	case "PublishPending", "publishpending":
		*x = SyncgroupStatusPublishPending
		return nil
	case "PublishRejected", "publishrejected":
		*x = SyncgroupStatusPublishRejected
		return nil
	case "Running", "running":
		*x = SyncgroupStatusRunning
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in interfaces.SyncgroupStatus", label)
}

// String returns the string label of x.
func (x SyncgroupStatus) String() string {
	switch x {
	case SyncgroupStatusPublishPending:
		return "PublishPending"
	case SyncgroupStatusPublishRejected:
		return "PublishRejected"
	case SyncgroupStatusRunning:
		return "Running"
	}
	return ""
}

func (SyncgroupStatus) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.SyncgroupStatus"`
	Enum struct{ PublishPending, PublishRejected, Running string }
}) {
}

func (m *SyncgroupStatus) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SyncgroupStatus); err != nil {
		return err
	}
	return nil
}

func (m *SyncgroupStatus) MakeVDLTarget() vdl.Target {
	return &SyncgroupStatusTarget{Value: m}
}

type SyncgroupStatusTarget struct {
	Value *SyncgroupStatus
	vdl.TargetBase
}

func (t *SyncgroupStatusTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SyncgroupStatus) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SyncgroupStatus)
	}
	switch src {
	case "PublishPending":
		*t.Value = 0
	case "PublishRejected":
		*t.Value = 1
	case "Running":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum %v", src, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SyncgroupStatus)
	}

	return nil
}

// Syncgroup contains the state of a syncgroup.
type Syncgroup struct {
	Id          GroupId                              // globally unique identifier generated by Syncbase
	Name        string                               // globally unique Vanadium name chosen by app
	SpecVersion string                               // version on syncgroup spec for concurrency control
	Spec        nosql.SyncgroupSpec                  // app-given specification
	Creator     string                               // Creator's Vanadium name
	AppName     string                               // Globally unique App name
	DbName      string                               // Database name within the App
	Status      SyncgroupStatus                      // Status of the syncgroup
	Joiners     map[string]nosql.SyncgroupMemberInfo // map of joiners to their metadata
}

func (Syncgroup) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.Syncgroup"`
}) {
}

func (m *Syncgroup) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Syncgroup == nil || __VDLType4 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Id")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Id.FillVDLTarget(fieldTarget3, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GroupId); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.Name), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("SpecVersion")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromString(string(m.SpecVersion), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Spec")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Spec.FillVDLTarget(fieldTarget9, __VDLType_v_io_v23_services_syncbase_nosql_SyncgroupSpec); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("Creator")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget11.FromString(string(m.Creator), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("AppName")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget13.FromString(string(m.AppName), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("DbName")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget15.FromString(string(m.DbName), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	keyTarget16, fieldTarget17, err := fieldsTarget1.StartField("Status")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Status.FillVDLTarget(fieldTarget17, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SyncgroupStatus); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget16, fieldTarget17); err != nil {
			return err
		}
	}
	keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("Joiners")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget20, err := fieldTarget19.StartMap(__VDLType5, len(m.Joiners))
		if err != nil {
			return err
		}
		for key22, value24 := range m.Joiners {
			keyTarget21, err := mapTarget20.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget21.FromString(string(key22), vdl.StringType); err != nil {
				return err
			}
			valueTarget23, err := mapTarget20.FinishKeyStartField(keyTarget21)
			if err != nil {
				return err
			}

			if err := value24.FillVDLTarget(valueTarget23, __VDLType_v_io_v23_services_syncbase_nosql_SyncgroupMemberInfo); err != nil {
				return err
			}
			if err := mapTarget20.FinishField(keyTarget21, valueTarget23); err != nil {
				return err
			}
		}
		if err := fieldTarget19.FinishMap(mapTarget20); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Syncgroup) MakeVDLTarget() vdl.Target {
	return &SyncgroupTarget{Value: m}
}

type SyncgroupTarget struct {
	Value             *Syncgroup
	idTarget          GroupIdTarget
	nameTarget        vdl.StringTarget
	specVersionTarget vdl.StringTarget
	specTarget        nosql.SyncgroupSpecTarget
	creatorTarget     vdl.StringTarget
	appNameTarget     vdl.StringTarget
	dbNameTarget      vdl.StringTarget
	statusTarget      SyncgroupStatusTarget
	joinersTarget     unnamed_6d61705b737472696e675d762e696f2f7632332f73657276696365732f73796e63626173652f6e6f73716c2e53796e6367726f75704d656d626572496e666f207374727563747b53796e635072696f7269747920627974653b497353657276657220626f6f6c7dTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SyncgroupTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Syncgroup) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Syncgroup)
	}
	return t, nil
}
func (t *SyncgroupTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Id":
		t.idTarget.Value = &t.Value.Id
		target, err := &t.idTarget, error(nil)
		return nil, target, err
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "SpecVersion":
		t.specVersionTarget.Value = &t.Value.SpecVersion
		target, err := &t.specVersionTarget, error(nil)
		return nil, target, err
	case "Spec":
		t.specTarget.Value = &t.Value.Spec
		target, err := &t.specTarget, error(nil)
		return nil, target, err
	case "Creator":
		t.creatorTarget.Value = &t.Value.Creator
		target, err := &t.creatorTarget, error(nil)
		return nil, target, err
	case "AppName":
		t.appNameTarget.Value = &t.Value.AppName
		target, err := &t.appNameTarget, error(nil)
		return nil, target, err
	case "DbName":
		t.dbNameTarget.Value = &t.Value.DbName
		target, err := &t.dbNameTarget, error(nil)
		return nil, target, err
	case "Status":
		t.statusTarget.Value = &t.Value.Status
		target, err := &t.statusTarget, error(nil)
		return nil, target, err
	case "Joiners":
		t.joinersTarget.Value = &t.Value.Joiners
		target, err := &t.joinersTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Syncgroup)
	}
}
func (t *SyncgroupTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SyncgroupTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[string]nosql.SyncgroupMemberInfo
type unnamed_6d61705b737472696e675d762e696f2f7632332f73657276696365732f73796e63626173652f6e6f73716c2e53796e6367726f75704d656d626572496e666f207374727563747b53796e635072696f7269747920627974653b497353657276657220626f6f6c7dTarget struct {
	Value      *map[string]nosql.SyncgroupMemberInfo
	currKey    string
	currElem   nosql.SyncgroupMemberInfo
	keyTarget  vdl.StringTarget
	elemTarget nosql.SyncgroupMemberInfoTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *unnamed_6d61705b737472696e675d762e696f2f7632332f73657276696365732f73796e63626173652f6e6f73716c2e53796e6367726f75704d656d626572496e666f207374727563747b53796e635072696f7269747920627974653b497353657276657220626f6f6c7dTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if !vdl.Compatible(tt, __VDLType5) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType5)
	}
	*t.Value = make(map[string]nosql.SyncgroupMemberInfo)
	return t, nil
}
func (t *unnamed_6d61705b737472696e675d762e696f2f7632332f73657276696365732f73796e63626173652f6e6f73716c2e53796e6367726f75704d656d626572496e666f207374727563747b53796e635072696f7269747920627974653b497353657276657220626f6f6c7dTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *unnamed_6d61705b737472696e675d762e696f2f7632332f73657276696365732f73796e63626173652f6e6f73716c2e53796e6367726f75704d656d626572496e666f207374727563747b53796e635072696f7269747920627974653b497353657276657220626f6f6c7dTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = nosql.SyncgroupMemberInfo{}
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *unnamed_6d61705b737472696e675d762e696f2f7632332f73657276696365732f73796e63626173652f6e6f73716c2e53796e6367726f75704d656d626572496e666f207374727563747b53796e635072696f7269747920627974653b497353657276657220626f6f6c7dTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *unnamed_6d61705b737472696e675d762e696f2f7632332f73657276696365732f73796e63626173652f6e6f73716c2e53796e6367726f75704d656d626572496e666f207374727563747b53796e635072696f7269747920627974653b497353657276657220626f6f6c7dTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type (
	// DeltaReq represents any single field of the DeltaReq union type.
	//
	// DeltaReq contains a request to sync either data or syncgroup metadata for a
	// Database.
	DeltaReq interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the DeltaReq union type.
		__VDLReflect(__DeltaReqReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// DeltaReqSgs represents field Sgs of the DeltaReq union type.
	DeltaReqSgs struct{ Value SgDeltaReq }
	// DeltaReqData represents field Data of the DeltaReq union type.
	DeltaReqData struct{ Value DataDeltaReq }
	// __DeltaReqReflect describes the DeltaReq union type.
	__DeltaReqReflect struct {
		Name  string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.DeltaReq"`
		Type  DeltaReq
		Union struct {
			Sgs  DeltaReqSgs
			Data DeltaReqData
		}
	}
)

func (x DeltaReqSgs) Index() int                     { return 0 }
func (x DeltaReqSgs) Interface() interface{}         { return x.Value }
func (x DeltaReqSgs) Name() string                   { return "Sgs" }
func (x DeltaReqSgs) __VDLReflect(__DeltaReqReflect) {}

func (m DeltaReqSgs) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaReq)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Sgs")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgDeltaReq); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m DeltaReqSgs) MakeVDLTarget() vdl.Target {
	return nil
}

func (x DeltaReqData) Index() int                     { return 1 }
func (x DeltaReqData) Interface() interface{}         { return x.Value }
func (x DeltaReqData) Name() string                   { return "Data" }
func (x DeltaReqData) __VDLReflect(__DeltaReqReflect) {}

func (m DeltaReqData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaReq)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Data")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DataDeltaReq); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m DeltaReqData) MakeVDLTarget() vdl.Target {
	return nil
}

// DataDeltaReq contains the initiator's genvectors and the set of syncgroups it
// is interested in within a Database (specified by the AppName/DbName) when
// requesting deltas for that Database.
type DataDeltaReq struct {
	AppName string
	DbName  string
	SgIds   map[GroupId]struct{}
	Gvs     Knowledge
}

func (DataDeltaReq) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.DataDeltaReq"`
}) {
}

func (m *DataDeltaReq) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DataDeltaReq == nil || __VDLType6 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("AppName")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.AppName), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("DbName")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.DbName), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("SgIds")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget8, err := fieldTarget7.StartSet(__VDLType7, len(m.SgIds))
		if err != nil {
			return err
		}
		for key10 := range m.SgIds {
			keyTarget9, err := setTarget8.StartKey()
			if err != nil {
				return err
			}

			if err := key10.FillVDLTarget(keyTarget9, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GroupId); err != nil {
				return err
			}
			if err := setTarget8.FinishKey(keyTarget9); err != nil {
				return err
			}
		}
		if err := fieldTarget7.FinishSet(setTarget8); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Gvs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Gvs.FillVDLTarget(fieldTarget12, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Knowledge); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *DataDeltaReq) MakeVDLTarget() vdl.Target {
	return &DataDeltaReqTarget{Value: m}
}

type DataDeltaReqTarget struct {
	Value         *DataDeltaReq
	appNameTarget vdl.StringTarget
	dbNameTarget  vdl.StringTarget
	sgIdsTarget   unnamed_7365745b762e696f2f782f7265662f73657276696365732f73796e63626173652f7365727665722f696e74657266616365732e47726f757049642075696e7436345dTarget
	gvsTarget     KnowledgeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DataDeltaReqTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DataDeltaReq) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DataDeltaReq)
	}
	return t, nil
}
func (t *DataDeltaReqTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "AppName":
		t.appNameTarget.Value = &t.Value.AppName
		target, err := &t.appNameTarget, error(nil)
		return nil, target, err
	case "DbName":
		t.dbNameTarget.Value = &t.Value.DbName
		target, err := &t.dbNameTarget, error(nil)
		return nil, target, err
	case "SgIds":
		t.sgIdsTarget.Value = &t.Value.SgIds
		target, err := &t.sgIdsTarget, error(nil)
		return nil, target, err
	case "Gvs":
		t.gvsTarget.Value = &t.Value.Gvs
		target, err := &t.gvsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DataDeltaReq)
	}
}
func (t *DataDeltaReqTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *DataDeltaReqTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[GroupId]struct{}
type unnamed_7365745b762e696f2f782f7265662f73657276696365732f73796e63626173652f7365727665722f696e74657266616365732e47726f757049642075696e7436345dTarget struct {
	Value     *map[GroupId]struct{}
	currKey   GroupId
	keyTarget GroupIdTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *unnamed_7365745b762e696f2f782f7265662f73657276696365732f73796e63626173652f7365727665722f696e74657266616365732e47726f757049642075696e7436345dTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if !vdl.Compatible(tt, __VDLType7) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType7)
	}
	*t.Value = make(map[GroupId]struct{})
	return t, nil
}
func (t *unnamed_7365745b762e696f2f782f7265662f73657276696365732f73796e63626173652f7365727665722f696e74657266616365732e47726f757049642075696e7436345dTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = GroupId(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *unnamed_7365745b762e696f2f782f7265662f73657276696365732f73796e63626173652f7365727665722f696e74657266616365732e47726f757049642075696e7436345dTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *unnamed_7365745b762e696f2f782f7265662f73657276696365732f73796e63626173652f7365727665722f696e74657266616365732e47726f757049642075696e7436345dTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// SgDeltaReq contains the initiator's genvectors for the syncgroups it is
// interested in within a Database (specified by the AppName/DbName) when
// requesting deltas for those syncgroups.
type SgDeltaReq struct {
	AppName string
	DbName  string
	Gvs     Knowledge // Contains a genvector per syncgroup.
}

func (SgDeltaReq) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.SgDeltaReq"`
}) {
}

func (m *SgDeltaReq) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgDeltaReq == nil || __VDLType8 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("AppName")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.AppName), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("DbName")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.DbName), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Gvs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Gvs.FillVDLTarget(fieldTarget7, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Knowledge); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SgDeltaReq) MakeVDLTarget() vdl.Target {
	return &SgDeltaReqTarget{Value: m}
}

type SgDeltaReqTarget struct {
	Value         *SgDeltaReq
	appNameTarget vdl.StringTarget
	dbNameTarget  vdl.StringTarget
	gvsTarget     KnowledgeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SgDeltaReqTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgDeltaReq) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgDeltaReq)
	}
	return t, nil
}
func (t *SgDeltaReqTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "AppName":
		t.appNameTarget.Value = &t.Value.AppName
		target, err := &t.appNameTarget, error(nil)
		return nil, target, err
	case "DbName":
		t.dbNameTarget.Value = &t.Value.DbName
		target, err := &t.dbNameTarget, error(nil)
		return nil, target, err
	case "Gvs":
		t.gvsTarget.Value = &t.Value.Gvs
		target, err := &t.gvsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgDeltaReq)
	}
}
func (t *SgDeltaReqTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SgDeltaReqTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type (
	// DeltaResp represents any single field of the DeltaResp union type.
	//
	// DeltaResp contains the responder's genvectors or the missing log records
	// returned in response to an initiator's request for deltas for a Database.
	DeltaResp interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the DeltaResp union type.
		__VDLReflect(__DeltaRespReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// DeltaRespRec represents field Rec of the DeltaResp union type.
	DeltaRespRec struct{ Value LogRec }
	// DeltaRespGvs represents field Gvs of the DeltaResp union type.
	DeltaRespGvs struct{ Value Knowledge }
	// __DeltaRespReflect describes the DeltaResp union type.
	__DeltaRespReflect struct {
		Name  string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.DeltaResp"`
		Type  DeltaResp
		Union struct {
			Rec DeltaRespRec
			Gvs DeltaRespGvs
		}
	}
)

func (x DeltaRespRec) Index() int                      { return 0 }
func (x DeltaRespRec) Interface() interface{}          { return x.Value }
func (x DeltaRespRec) Name() string                    { return "Rec" }
func (x DeltaRespRec) __VDLReflect(__DeltaRespReflect) {}

func (m DeltaRespRec) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rec")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m DeltaRespRec) MakeVDLTarget() vdl.Target {
	return nil
}

func (x DeltaRespGvs) Index() int                      { return 1 }
func (x DeltaRespGvs) Interface() interface{}          { return x.Value }
func (x DeltaRespGvs) Name() string                    { return "Gvs" }
func (x DeltaRespGvs) __VDLReflect(__DeltaRespReflect) {}

func (m DeltaRespGvs) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Gvs")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Knowledge); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m DeltaRespGvs) MakeVDLTarget() vdl.Target {
	return nil
}

// DeltaFinalResp contains the data returned at the end of a GetDeltas call.
type DeltaFinalResp struct {
	SgPriorities SgPriorities
}

func (DeltaFinalResp) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.DeltaFinalResp"`
}) {
}

func (m *DeltaFinalResp) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	__VDLEnsureNativeBuilt()
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("SgPriorities")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.SgPriorities.FillVDLTarget(fieldTarget3, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *DeltaFinalResp) MakeVDLTarget() vdl.Target {
	return &DeltaFinalRespTarget{Value: m}
}

type DeltaFinalRespTarget struct {
	Value              *DeltaFinalResp
	sgPrioritiesTarget SgPrioritiesTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DeltaFinalRespTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp)
	}
	return t, nil
}
func (t *DeltaFinalRespTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "SgPriorities":
		t.sgPrioritiesTarget.Value = &t.Value.SgPriorities
		target, err := &t.sgPrioritiesTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp)
	}
}
func (t *DeltaFinalRespTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *DeltaFinalRespTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type SgPrioritiesTarget struct {
	Value      *SgPriorities
	currKey    GroupId
	currElem   SgPriority
	keyTarget  GroupIdTarget
	elemTarget SgPriorityTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SgPrioritiesTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities)
	}
	*t.Value = make(SgPriorities)
	return t, nil
}
func (t *SgPrioritiesTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = GroupId(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SgPrioritiesTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().(SgPriority)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *SgPrioritiesTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SgPrioritiesTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SgPriorityTarget struct {
	Value            *SgPriority
	distanceTarget   vdl.Int32Target
	serverTimeTarget time_2.TimeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SgPriorityTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority)
	}
	return t, nil
}
func (t *SgPriorityTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Distance":
		t.distanceTarget.Value = &t.Value.Distance
		target, err := &t.distanceTarget, error(nil)
		return nil, target, err
	case "ServerTime":
		t.serverTimeTarget.Value = &t.Value.ServerTime
		target, err := &t.serverTimeTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority)
	}
}
func (t *SgPriorityTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SgPriorityTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// ChunkHash contains the hash of a chunk that is part of a blob's recipe.
type ChunkHash struct {
	Hash []byte
}

func (ChunkHash) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.ChunkHash"`
}) {
}

func (m *ChunkHash) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_ChunkHash == nil || __VDLType10 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Hash")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := fieldTarget3.FromBytes([]byte(m.Hash), __VDLType3); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ChunkHash) MakeVDLTarget() vdl.Target {
	return &ChunkHashTarget{Value: m}
}

type ChunkHashTarget struct {
	Value      *ChunkHash
	hashTarget vdl.BytesTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ChunkHashTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_ChunkHash) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_ChunkHash)
	}
	return t, nil
}
func (t *ChunkHashTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Hash":
		t.hashTarget.Value = &t.Value.Hash
		target, err := &t.hashTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_ChunkHash)
	}
}
func (t *ChunkHashTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ChunkHashTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// ChunkData contains the data of a chunk.
type ChunkData struct {
	Data []byte
}

func (ChunkData) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.ChunkData"`
}) {
}

func (m *ChunkData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_ChunkData == nil || __VDLType11 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Data")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := fieldTarget3.FromBytes([]byte(m.Data), __VDLType3); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ChunkData) MakeVDLTarget() vdl.Target {
	return &ChunkDataTarget{Value: m}
}

type ChunkDataTarget struct {
	Value      *ChunkData
	dataTarget vdl.BytesTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ChunkDataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_ChunkData) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_ChunkData)
	}
	return t, nil
}
func (t *ChunkDataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Data":
		t.dataTarget.Value = &t.Value.Data
		target, err := &t.dataTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_ChunkData)
	}
}
func (t *ChunkDataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ChunkDataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// TimeReq contains the send timestamp from the requester.
type TimeReq struct {
	SendTs time.Time
}

func (TimeReq) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.TimeReq"`
}) {
}

func (m *TimeReq) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	__VDLEnsureNativeBuilt()
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	var wireValue2 time_2.Time
	if err := time_2.TimeFromNative(&wireValue2, m.SendTs); err != nil {
		return err
	}

	keyTarget3, fieldTarget4, err := fieldsTarget1.StartField("SendTs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue2.FillVDLTarget(fieldTarget4, __VDLType_time_Time); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget3, fieldTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TimeReq) MakeVDLTarget() vdl.Target {
	return &TimeReqTarget{Value: m}
}

type TimeReqTarget struct {
	Value        *TimeReq
	sendTsTarget time_2.TimeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TimeReqTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq)
	}
	return t, nil
}
func (t *TimeReqTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "SendTs":
		t.sendTsTarget.Value = &t.Value.SendTs
		target, err := &t.sendTsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq)
	}
}
func (t *TimeReqTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TimeReqTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// TimeResp contains information needed by the requester to estimate the
// difference between the two vclocks and to decide whether to incorporate the
// peer's vclock data.
type TimeResp struct {
	OrigTs time.Time // when we sent request
	RecvTs time.Time // when peer received request
	SendTs time.Time // when peer sent response
	// NTP server timestamp from the most recent NTP sync, or zero value if none.
	// Note, the NTP sync may have been performed by some peer device.
	LastNtpTs time.Time
	// Number of reboots since last NTP sync, accumulated across all hops of p2p
	// clock sync.
	NumReboots uint16
	// Number of sync hops between peer's device and its source of LastNtpTs.
	NumHops uint16
}

func (TimeResp) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.TimeResp"`
}) {
}

func (m *TimeResp) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	__VDLEnsureNativeBuilt()
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	var wireValue2 time_2.Time
	if err := time_2.TimeFromNative(&wireValue2, m.OrigTs); err != nil {
		return err
	}

	keyTarget3, fieldTarget4, err := fieldsTarget1.StartField("OrigTs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue2.FillVDLTarget(fieldTarget4, __VDLType_time_Time); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget3, fieldTarget4); err != nil {
			return err
		}
	}
	var wireValue5 time_2.Time
	if err := time_2.TimeFromNative(&wireValue5, m.RecvTs); err != nil {
		return err
	}

	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("RecvTs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue5.FillVDLTarget(fieldTarget7, __VDLType_time_Time); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	var wireValue8 time_2.Time
	if err := time_2.TimeFromNative(&wireValue8, m.SendTs); err != nil {
		return err
	}

	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("SendTs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue8.FillVDLTarget(fieldTarget10, __VDLType_time_Time); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	var wireValue11 time_2.Time
	if err := time_2.TimeFromNative(&wireValue11, m.LastNtpTs); err != nil {
		return err
	}

	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("LastNtpTs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue11.FillVDLTarget(fieldTarget13, __VDLType_time_Time); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("NumReboots")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget15.FromUint(uint64(m.NumReboots), vdl.Uint16Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	keyTarget16, fieldTarget17, err := fieldsTarget1.StartField("NumHops")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget17.FromUint(uint64(m.NumHops), vdl.Uint16Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget16, fieldTarget17); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TimeResp) MakeVDLTarget() vdl.Target {
	return &TimeRespTarget{Value: m}
}

type TimeRespTarget struct {
	Value            *TimeResp
	origTsTarget     time_2.TimeTarget
	recvTsTarget     time_2.TimeTarget
	sendTsTarget     time_2.TimeTarget
	lastNtpTsTarget  time_2.TimeTarget
	numRebootsTarget vdl.Uint16Target
	numHopsTarget    vdl.Uint16Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TimeRespTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp)
	}
	return t, nil
}
func (t *TimeRespTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "OrigTs":
		t.origTsTarget.Value = &t.Value.OrigTs
		target, err := &t.origTsTarget, error(nil)
		return nil, target, err
	case "RecvTs":
		t.recvTsTarget.Value = &t.Value.RecvTs
		target, err := &t.recvTsTarget, error(nil)
		return nil, target, err
	case "SendTs":
		t.sendTsTarget.Value = &t.Value.SendTs
		target, err := &t.sendTsTarget, error(nil)
		return nil, target, err
	case "LastNtpTs":
		t.lastNtpTsTarget.Value = &t.Value.LastNtpTs
		target, err := &t.lastNtpTsTarget, error(nil)
		return nil, target, err
	case "NumReboots":
		t.numRebootsTarget.Value = &t.Value.NumReboots
		target, err := &t.numRebootsTarget, error(nil)
		return nil, target, err
	case "NumHops":
		t.numHopsTarget.Value = &t.Value.NumHops
		target, err := &t.numHopsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp)
	}
}
func (t *TimeRespTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TimeRespTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// A SgPriority represents data used to decide whether to transfer blob ownership
// between two devices.
type SgPriority struct {
	Distance   int32     // number of hops from a server-quality member of the syncgroup
	ServerTime time.Time // when data from a server-quality member reached this device
}

func (SgPriority) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.SgPriority"`
}) {
}

func (m *SgPriority) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	__VDLEnsureNativeBuilt()
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Distance")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromInt(int64(m.Distance), vdl.Int32Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	var wireValue4 time_2.Time
	if err := time_2.TimeFromNative(&wireValue4, m.ServerTime); err != nil {
		return err
	}

	keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("ServerTime")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue4.FillVDLTarget(fieldTarget6, __VDLType_time_Time); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SgPriority) MakeVDLTarget() vdl.Target {
	return &SgPriorityTarget{Value: m}
}

// A SgPriorities maps syncgroup IDs to SgPriority structures.  It is sent and
// received in GetDeltas calls to allow the participants to assess who has
// higher priorities for keeping blobs.
type SgPriorities map[GroupId]SgPriority

func (SgPriorities) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.SgPriorities"`
}) {
}

func (m *SgPriorities) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GroupId); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SgPriorities) MakeVDLTarget() vdl.Target {
	return &SgPrioritiesTarget{Value: m}
}

// A BlobSharesBySyncgroup maps syncgroup IDs to integer share numbers that a
// syncbase instance may have for a blob.
type BlobSharesBySyncgroup map[GroupId]int32

func (BlobSharesBySyncgroup) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.BlobSharesBySyncgroup"`
}) {
}

func (m *BlobSharesBySyncgroup) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_BlobSharesBySyncgroup, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GroupId); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromInt(int64(value5), vdl.Int32Type); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BlobSharesBySyncgroup) MakeVDLTarget() vdl.Target {
	return &BlobSharesBySyncgroupTarget{Value: m}
}

type BlobSharesBySyncgroupTarget struct {
	Value      *BlobSharesBySyncgroup
	currKey    GroupId
	currElem   int32
	keyTarget  GroupIdTarget
	elemTarget vdl.Int32Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *BlobSharesBySyncgroupTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_BlobSharesBySyncgroup) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_BlobSharesBySyncgroup)
	}
	*t.Value = make(BlobSharesBySyncgroup)
	return t, nil
}
func (t *BlobSharesBySyncgroupTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = GroupId(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *BlobSharesBySyncgroupTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = int32(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *BlobSharesBySyncgroupTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *BlobSharesBySyncgroupTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// A Signpost is a hint to syncbase of the device on which a blob may be found.
// It represents the data known about a blob even when the blob itself is not
// present on the device.
type Signpost struct {
	Peer   string               // Syncbase from which the presence of this BlobRef was first learned.
	Source string               // Syncbase that originated this blob.
	SgIds  map[GroupId]struct{} // SyncGroups through which the BlobRef was learned.
}

func (Signpost) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.Signpost"`
}) {
}

func (m *Signpost) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Signpost == nil || __VDLType15 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Peer")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Peer), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Source")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.Source), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("SgIds")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget8, err := fieldTarget7.StartSet(__VDLType7, len(m.SgIds))
		if err != nil {
			return err
		}
		for key10 := range m.SgIds {
			keyTarget9, err := setTarget8.StartKey()
			if err != nil {
				return err
			}

			if err := key10.FillVDLTarget(keyTarget9, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GroupId); err != nil {
				return err
			}
			if err := setTarget8.FinishKey(keyTarget9); err != nil {
				return err
			}
		}
		if err := fieldTarget7.FinishSet(setTarget8); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Signpost) MakeVDLTarget() vdl.Target {
	return &SignpostTarget{Value: m}
}

type SignpostTarget struct {
	Value        *Signpost
	peerTarget   vdl.StringTarget
	sourceTarget vdl.StringTarget
	sgIdsTarget  unnamed_7365745b762e696f2f782f7265662f73657276696365732f73796e63626173652f7365727665722f696e74657266616365732e47726f757049642075696e7436345dTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SignpostTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if !vdl.Compatible(tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Signpost) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Signpost)
	}
	return t, nil
}
func (t *SignpostTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Peer":
		t.peerTarget.Value = &t.Value.Peer
		target, err := &t.peerTarget, error(nil)
		return nil, target, err
	case "Source":
		t.sourceTarget.Value = &t.Value.Source
		target, err := &t.sourceTarget, error(nil)
		return nil, target, err
	case "SgIds":
		t.sgIdsTarget.Value = &t.Value.SgIds
		target, err := &t.sgIdsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Signpost)
	}
}
func (t *SignpostTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SignpostTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func init() {
	vdl.Register((*GenVector)(nil))
	vdl.Register((*Knowledge)(nil))
	vdl.Register((*LogRecMetadata)(nil))
	vdl.Register((*LogRec)(nil))
	vdl.Register((*GroupId)(nil))
	vdl.Register((*SyncgroupStatus)(nil))
	vdl.Register((*Syncgroup)(nil))
	vdl.Register((*DeltaReq)(nil))
	vdl.Register((*DataDeltaReq)(nil))
	vdl.Register((*SgDeltaReq)(nil))
	vdl.Register((*DeltaResp)(nil))
	vdl.Register((*DeltaFinalResp)(nil))
	vdl.Register((*ChunkHash)(nil))
	vdl.Register((*ChunkData)(nil))
	vdl.Register((*TimeReq)(nil))
	vdl.Register((*TimeResp)(nil))
	vdl.Register((*SgPriority)(nil))
	vdl.Register((*SgPriorities)(nil))
	vdl.Register((*BlobSharesBySyncgroup)(nil))
	vdl.Register((*Signpost)(nil))
}

var __VDLType11 *vdl.Type = vdl.TypeOf((*ChunkData)(nil))
var __VDLType10 *vdl.Type = vdl.TypeOf((*ChunkHash)(nil))
var __VDLType6 *vdl.Type = vdl.TypeOf((*DataDeltaReq)(nil))
var __VDLType9 *vdl.Type

func __VDLType9_gen() *vdl.Type {
	__VDLType9Builder := vdl.TypeBuilder{}

	__VDLType91 := __VDLType9Builder.Optional()
	__VDLType92 := __VDLType9Builder.Struct()
	__VDLType93 := __VDLType9Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.DeltaFinalResp").AssignBase(__VDLType92)
	__VDLType94 := __VDLType9Builder.Map()
	__VDLType95 := __VDLType9Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.SgPriorities").AssignBase(__VDLType94)
	__VDLType96 := vdl.Uint64Type
	__VDLType97 := __VDLType9Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.GroupId").AssignBase(__VDLType96)
	__VDLType94.AssignKey(__VDLType97)
	__VDLType98 := __VDLType9Builder.Struct()
	__VDLType99 := __VDLType9Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.SgPriority").AssignBase(__VDLType98)
	__VDLType910 := vdl.Int32Type
	__VDLType98.AppendField("Distance", __VDLType910)
	__VDLType911 := __VDLType9Builder.Struct()
	__VDLType912 := __VDLType9Builder.Named("time.Time").AssignBase(__VDLType911)
	__VDLType913 := vdl.Int64Type
	__VDLType911.AppendField("Seconds", __VDLType913)
	__VDLType911.AppendField("Nanos", __VDLType910)
	__VDLType98.AppendField("ServerTime", __VDLType912)
	__VDLType94.AssignElem(__VDLType99)
	__VDLType92.AppendField("SgPriorities", __VDLType95)
	__VDLType91.AssignElem(__VDLType93)
	__VDLType9Builder.Build()
	__VDLType9v, err := __VDLType91.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType9v
}
func init() {
	__VDLType9 = __VDLType9_gen()
}

var __VDLType2 *vdl.Type

func __VDLType2_gen() *vdl.Type {
	__VDLType2Builder := vdl.TypeBuilder{}

	__VDLType21 := __VDLType2Builder.Optional()
	__VDLType22 := __VDLType2Builder.Struct()
	__VDLType23 := __VDLType2Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRec").AssignBase(__VDLType22)
	__VDLType24 := __VDLType2Builder.Struct()
	__VDLType25 := __VDLType2Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata").AssignBase(__VDLType24)
	__VDLType26 := vdl.Uint64Type
	__VDLType24.AppendField("Id", __VDLType26)
	__VDLType24.AppendField("Gen", __VDLType26)
	__VDLType27 := vdl.ByteType
	__VDLType24.AppendField("RecType", __VDLType27)
	__VDLType28 := vdl.StringType
	__VDLType24.AppendField("ObjId", __VDLType28)
	__VDLType24.AppendField("CurVers", __VDLType28)
	__VDLType29 := __VDLType2Builder.List()
	__VDLType29.AssignElem(__VDLType28)
	__VDLType24.AppendField("Parents", __VDLType29)
	__VDLType210 := __VDLType2Builder.Struct()
	__VDLType211 := __VDLType2Builder.Named("time.Time").AssignBase(__VDLType210)
	__VDLType212 := vdl.Int64Type
	__VDLType210.AppendField("Seconds", __VDLType212)
	__VDLType213 := vdl.Int32Type
	__VDLType210.AppendField("Nanos", __VDLType213)
	__VDLType24.AppendField("UpdTime", __VDLType211)
	__VDLType24.AppendField("PermId", __VDLType28)
	__VDLType24.AppendField("PermVers", __VDLType28)
	__VDLType214 := vdl.BoolType
	__VDLType24.AppendField("Delete", __VDLType214)
	__VDLType24.AppendField("BatchId", __VDLType26)
	__VDLType24.AppendField("BatchCount", __VDLType26)
	__VDLType22.AppendField("Metadata", __VDLType25)
	__VDLType215 := __VDLType2Builder.List()
	__VDLType215.AssignElem(__VDLType27)
	__VDLType22.AppendField("Value", __VDLType215)
	__VDLType22.AppendField("Shell", __VDLType214)
	__VDLType21.AssignElem(__VDLType23)
	__VDLType2Builder.Build()
	__VDLType2v, err := __VDLType21.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType2v
}
func init() {
	__VDLType2 = __VDLType2_gen()
}

var __VDLType0 *vdl.Type

func __VDLType0_gen() *vdl.Type {
	__VDLType0Builder := vdl.TypeBuilder{}

	__VDLType01 := __VDLType0Builder.Optional()
	__VDLType02 := __VDLType0Builder.Struct()
	__VDLType03 := __VDLType0Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata").AssignBase(__VDLType02)
	__VDLType04 := vdl.Uint64Type
	__VDLType02.AppendField("Id", __VDLType04)
	__VDLType02.AppendField("Gen", __VDLType04)
	__VDLType05 := vdl.ByteType
	__VDLType02.AppendField("RecType", __VDLType05)
	__VDLType06 := vdl.StringType
	__VDLType02.AppendField("ObjId", __VDLType06)
	__VDLType02.AppendField("CurVers", __VDLType06)
	__VDLType07 := __VDLType0Builder.List()
	__VDLType07.AssignElem(__VDLType06)
	__VDLType02.AppendField("Parents", __VDLType07)
	__VDLType08 := __VDLType0Builder.Struct()
	__VDLType09 := __VDLType0Builder.Named("time.Time").AssignBase(__VDLType08)
	__VDLType010 := vdl.Int64Type
	__VDLType08.AppendField("Seconds", __VDLType010)
	__VDLType011 := vdl.Int32Type
	__VDLType08.AppendField("Nanos", __VDLType011)
	__VDLType02.AppendField("UpdTime", __VDLType09)
	__VDLType02.AppendField("PermId", __VDLType06)
	__VDLType02.AppendField("PermVers", __VDLType06)
	__VDLType012 := vdl.BoolType
	__VDLType02.AppendField("Delete", __VDLType012)
	__VDLType02.AppendField("BatchId", __VDLType04)
	__VDLType02.AppendField("BatchCount", __VDLType04)
	__VDLType01.AssignElem(__VDLType03)
	__VDLType0Builder.Build()
	__VDLType0v, err := __VDLType01.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType0v
}
func init() {
	__VDLType0 = __VDLType0_gen()
}

var __VDLType8 *vdl.Type = vdl.TypeOf((*SgDeltaReq)(nil))
var __VDLType14 *vdl.Type

func __VDLType14_gen() *vdl.Type {
	__VDLType14Builder := vdl.TypeBuilder{}

	__VDLType141 := __VDLType14Builder.Optional()
	__VDLType142 := __VDLType14Builder.Struct()
	__VDLType143 := __VDLType14Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.SgPriority").AssignBase(__VDLType142)
	__VDLType144 := vdl.Int32Type
	__VDLType142.AppendField("Distance", __VDLType144)
	__VDLType145 := __VDLType14Builder.Struct()
	__VDLType146 := __VDLType14Builder.Named("time.Time").AssignBase(__VDLType145)
	__VDLType147 := vdl.Int64Type
	__VDLType145.AppendField("Seconds", __VDLType147)
	__VDLType145.AppendField("Nanos", __VDLType144)
	__VDLType142.AppendField("ServerTime", __VDLType146)
	__VDLType141.AssignElem(__VDLType143)
	__VDLType14Builder.Build()
	__VDLType14v, err := __VDLType141.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType14v
}
func init() {
	__VDLType14 = __VDLType14_gen()
}

var __VDLType15 *vdl.Type = vdl.TypeOf((*Signpost)(nil))
var __VDLType4 *vdl.Type = vdl.TypeOf((*Syncgroup)(nil))
var __VDLType12 *vdl.Type

func __VDLType12_gen() *vdl.Type {
	__VDLType12Builder := vdl.TypeBuilder{}

	__VDLType121 := __VDLType12Builder.Optional()
	__VDLType122 := __VDLType12Builder.Struct()
	__VDLType123 := __VDLType12Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.TimeReq").AssignBase(__VDLType122)
	__VDLType124 := __VDLType12Builder.Struct()
	__VDLType125 := __VDLType12Builder.Named("time.Time").AssignBase(__VDLType124)
	__VDLType126 := vdl.Int64Type
	__VDLType124.AppendField("Seconds", __VDLType126)
	__VDLType127 := vdl.Int32Type
	__VDLType124.AppendField("Nanos", __VDLType127)
	__VDLType122.AppendField("SendTs", __VDLType125)
	__VDLType121.AssignElem(__VDLType123)
	__VDLType12Builder.Build()
	__VDLType12v, err := __VDLType121.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType12v
}
func init() {
	__VDLType12 = __VDLType12_gen()
}

var __VDLType13 *vdl.Type

func __VDLType13_gen() *vdl.Type {
	__VDLType13Builder := vdl.TypeBuilder{}

	__VDLType131 := __VDLType13Builder.Optional()
	__VDLType132 := __VDLType13Builder.Struct()
	__VDLType133 := __VDLType13Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.TimeResp").AssignBase(__VDLType132)
	__VDLType134 := __VDLType13Builder.Struct()
	__VDLType135 := __VDLType13Builder.Named("time.Time").AssignBase(__VDLType134)
	__VDLType136 := vdl.Int64Type
	__VDLType134.AppendField("Seconds", __VDLType136)
	__VDLType137 := vdl.Int32Type
	__VDLType134.AppendField("Nanos", __VDLType137)
	__VDLType132.AppendField("OrigTs", __VDLType135)
	__VDLType132.AppendField("RecvTs", __VDLType135)
	__VDLType132.AppendField("SendTs", __VDLType135)
	__VDLType132.AppendField("LastNtpTs", __VDLType135)
	__VDLType138 := vdl.Uint16Type
	__VDLType132.AppendField("NumReboots", __VDLType138)
	__VDLType132.AppendField("NumHops", __VDLType138)
	__VDLType131.AssignElem(__VDLType133)
	__VDLType13Builder.Build()
	__VDLType13v, err := __VDLType131.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType13v
}
func init() {
	__VDLType13 = __VDLType13_gen()
}

var __VDLType3 *vdl.Type = vdl.TypeOf([]byte(nil))
var __VDLType1 *vdl.Type = vdl.TypeOf([]string(nil))
var __VDLType5 *vdl.Type = vdl.TypeOf(map[string]nosql.SyncgroupMemberInfo(nil))
var __VDLType7 *vdl.Type = vdl.TypeOf(map[GroupId]struct{}(nil))
var __VDLType_time_Time *vdl.Type

func __VDLType_time_Time_gen() *vdl.Type {
	__VDLType_time_TimeBuilder := vdl.TypeBuilder{}

	__VDLType_time_Time1 := __VDLType_time_TimeBuilder.Struct()
	__VDLType_time_Time2 := __VDLType_time_TimeBuilder.Named("time.Time").AssignBase(__VDLType_time_Time1)
	__VDLType_time_Time3 := vdl.Int64Type
	__VDLType_time_Time1.AppendField("Seconds", __VDLType_time_Time3)
	__VDLType_time_Time4 := vdl.Int32Type
	__VDLType_time_Time1.AppendField("Nanos", __VDLType_time_Time4)
	__VDLType_time_TimeBuilder.Build()
	__VDLType_time_Timev, err := __VDLType_time_Time2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_time_Timev
}
func init() {
	__VDLType_time_Time = __VDLType_time_Time_gen()
}

var __VDLType_v_io_v23_services_syncbase_nosql_SyncgroupMemberInfo *vdl.Type = vdl.TypeOf(nosql.SyncgroupMemberInfo{})
var __VDLType_v_io_v23_services_syncbase_nosql_SyncgroupSpec *vdl.Type = vdl.TypeOf(nosql.SyncgroupSpec{})
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_BlobSharesBySyncgroup *vdl.Type = vdl.TypeOf(BlobSharesBySyncgroup(nil))
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_ChunkData *vdl.Type = vdl.TypeOf(ChunkData{})
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_ChunkHash *vdl.Type = vdl.TypeOf(ChunkHash{})
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DataDeltaReq *vdl.Type = vdl.TypeOf(DataDeltaReq{})
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp *vdl.Type

func __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp_gen() *vdl.Type {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder := vdl.TypeBuilder{}

	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp1 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp2 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.DeltaFinalResp").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp1)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp3 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder.Map()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp4 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.SgPriorities").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp5 := vdl.Uint64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp6 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.GroupId").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp3.AssignKey(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp6)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp7 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp8 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.SgPriority").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp9 := vdl.Int32Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp7.AppendField("Distance", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp10 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp11 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder.Named("time.Time").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp10)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp12 := vdl.Int64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp10.AppendField("Seconds", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp12)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp10.AppendField("Nanos", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp7.AppendField("ServerTime", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp11)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp3.AssignElem(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp8)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp1.AppendField("SgPriorities", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespBuilder.Build()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespv, err := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalRespv
}
func init() {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp_gen()
}

var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaReq *vdl.Type = vdl.TypeOf(DeltaReq(DeltaReqSgs{SgDeltaReq{}}))
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp *vdl.Type

func __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp_gen() *vdl.Type {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder := vdl.TypeBuilder{}

	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp1 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Union()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp2 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.DeltaResp").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp1)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp3 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp4 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRec").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp6 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp7 := vdl.Uint64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("Id", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("Gen", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp8 := vdl.ByteType
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("RecType", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp8)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp9 := vdl.StringType
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("ObjId", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("CurVers", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp10 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.List()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp10.AssignElem(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("Parents", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp10)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp11 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp12 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Named("time.Time").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp11)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp13 := vdl.Int64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp11.AppendField("Seconds", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp13)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp14 := vdl.Int32Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp11.AppendField("Nanos", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp14)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("UpdTime", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp12)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("PermId", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("PermVers", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp15 := vdl.BoolType
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("Delete", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp15)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("BatchId", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp5.AppendField("BatchCount", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp3.AppendField("Metadata", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp6)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp16 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.List()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp16.AssignElem(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp8)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp3.AppendField("Value", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp16)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp3.AppendField("Shell", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp15)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp1.AppendField("Rec", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp17 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Map()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp18 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.Knowledge").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp17)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp17.AssignKey(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp19 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Map()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp20 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.GenVector").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp19)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp19.AssignKey(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp19.AssignElem(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp17.AssignElem(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp20)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp1.AppendField("Gvs", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp18)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespBuilder.Build()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespv, err := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaRespv
}
func init() {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp_gen()
}

var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GenVector *vdl.Type = vdl.TypeOf(GenVector(nil))
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_GroupId *vdl.Type = vdl.TypeOf(GroupId(0))
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Knowledge *vdl.Type = vdl.TypeOf(Knowledge(nil))
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec *vdl.Type

func __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec_gen() *vdl.Type {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecBuilder := vdl.TypeBuilder{}

	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec1 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec2 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRec").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec1)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec4 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec5 := vdl.Uint64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("Id", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("Gen", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec6 := vdl.ByteType
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("RecType", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec6)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec7 := vdl.StringType
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("ObjId", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("CurVers", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec8 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecBuilder.List()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec8.AssignElem(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("Parents", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec8)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec9 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec10 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecBuilder.Named("time.Time").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec11 := vdl.Int64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec9.AppendField("Seconds", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec11)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec12 := vdl.Int32Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec9.AppendField("Nanos", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec12)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("UpdTime", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec10)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("PermId", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("PermVers", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec13 := vdl.BoolType
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("Delete", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec13)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("BatchId", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec3.AppendField("BatchCount", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec1.AppendField("Metadata", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec14 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecBuilder.List()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec14.AssignElem(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec6)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec1.AppendField("Value", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec14)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec1.AppendField("Shell", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec13)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecBuilder.Build()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecv, err := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecv
}
func init() {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec_gen()
}

var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata *vdl.Type

func __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata_gen() *vdl.Type {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder := vdl.TypeBuilder{}

	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata2 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata3 := vdl.Uint64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("Id", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("Gen", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata4 := vdl.ByteType
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("RecType", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5 := vdl.StringType
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("ObjId", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("CurVers", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata6 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.List()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata6.AssignElem(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("Parents", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata6)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata7 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata8 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.Named("time.Time").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata9 := vdl.Int64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata7.AppendField("Seconds", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata10 := vdl.Int32Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata7.AppendField("Nanos", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata10)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("UpdTime", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata8)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("PermId", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("PermVers", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata11 := vdl.BoolType
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("Delete", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata11)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("BatchId", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("BatchCount", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.Build()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadatav, err := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadatav
}
func init() {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata_gen()
}

var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgDeltaReq *vdl.Type = vdl.TypeOf(SgDeltaReq{})
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities *vdl.Type

func __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities_gen() *vdl.Type {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesBuilder := vdl.TypeBuilder{}

	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities1 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesBuilder.Map()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities2 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.SgPriorities").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities1)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities3 := vdl.Uint64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities4 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.GroupId").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities1.AssignKey(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities5 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities6 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.SgPriority").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities7 := vdl.Int32Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities5.AppendField("Distance", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities8 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities9 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesBuilder.Named("time.Time").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities8)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities10 := vdl.Int64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities8.AppendField("Seconds", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities10)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities8.AppendField("Nanos", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities5.AppendField("ServerTime", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities9)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities1.AssignElem(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities6)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesBuilder.Build()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesv, err := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPrioritiesv
}
func init() {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities_gen()
}

var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority *vdl.Type

func __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority_gen() *vdl.Type {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorityBuilder := vdl.TypeBuilder{}

	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority1 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorityBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority2 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorityBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.SgPriority").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority1)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority3 := vdl.Int32Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority1.AppendField("Distance", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority4 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorityBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority5 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorityBuilder.Named("time.Time").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority6 := vdl.Int64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority4.AppendField("Seconds", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority6)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority4.AppendField("Nanos", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority1.AppendField("ServerTime", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorityBuilder.Build()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorityv, err := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorityv
}
func init() {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority_gen()
}

var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Signpost *vdl.Type = vdl.TypeOf(Signpost{})
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_Syncgroup *vdl.Type = vdl.TypeOf(Syncgroup{})
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SyncgroupStatus *vdl.Type = vdl.TypeOf(SyncgroupStatusPublishPending)
var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq *vdl.Type

func __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq_gen() *vdl.Type {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReqBuilder := vdl.TypeBuilder{}

	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq1 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReqBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq2 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReqBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.TimeReq").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq1)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq3 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReqBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq4 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReqBuilder.Named("time.Time").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq5 := vdl.Int64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq3.AppendField("Seconds", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq6 := vdl.Int32Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq3.AppendField("Nanos", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq6)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq1.AppendField("SendTs", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReqBuilder.Build()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReqv, err := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReqv
}
func init() {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq_gen()
}

var __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp *vdl.Type

func __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp_gen() *vdl.Type {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeRespBuilder := vdl.TypeBuilder{}

	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp1 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeRespBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp2 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeRespBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.TimeResp").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp1)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp3 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeRespBuilder.Struct()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp4 := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeRespBuilder.Named("time.Time").AssignBase(__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp3)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp5 := vdl.Int64Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp3.AppendField("Seconds", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp5)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp6 := vdl.Int32Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp3.AppendField("Nanos", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp6)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp1.AppendField("OrigTs", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp1.AppendField("RecvTs", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp1.AppendField("SendTs", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp1.AppendField("LastNtpTs", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp4)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp7 := vdl.Uint16Type
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp1.AppendField("NumReboots", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp1.AppendField("NumHops", __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp7)
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeRespBuilder.Build()
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeRespv, err := __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeRespv
}
func init() {
	__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp_gen()
}
func __VDLEnsureNativeBuilt() {
	if __VDLType9 == nil {
		__VDLType9 = __VDLType9_gen()
	}
	if __VDLType2 == nil {
		__VDLType2 = __VDLType2_gen()
	}
	if __VDLType0 == nil {
		__VDLType0 = __VDLType0_gen()
	}
	if __VDLType14 == nil {
		__VDLType14 = __VDLType14_gen()
	}
	if __VDLType12 == nil {
		__VDLType12 = __VDLType12_gen()
	}
	if __VDLType13 == nil {
		__VDLType13 = __VDLType13_gen()
	}
	if __VDLType_time_Time == nil {
		__VDLType_time_Time = __VDLType_time_Time_gen()
	}
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp == nil {
		__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaFinalResp_gen()
	}
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp == nil {
		__VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_DeltaResp_gen()
	}
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec == nil {
		__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRec_gen()
	}
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata == nil {
		__VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata_gen()
	}
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities == nil {
		__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriorities_gen()
	}
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority == nil {
		__VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_SgPriority_gen()
	}
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq == nil {
		__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeReq_gen()
	}
	if __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp == nil {
		__VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp = __VDLType_v_io_x_ref_services_syncbase_server_interfaces_TimeResp_gen()
	}
}

const NoGroupId = GroupId(0)

// NodeRec type log record adds a new node in the dag.
const NodeRec = byte(0)

// LinkRec type log record adds a new link in the dag. Link records are
// added when a conflict is resolved by picking the local or the remote
// version as the resolution of a conflict, instead of creating a new
// version.
const LinkRec = byte(1)

var (
	ErrDupSyncgroupPublish = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.DupSyncgroupPublish", verror.NoRetry, "{1:}{2:} duplicate publish on syncgroup: {3}")
	ErrConnFail            = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.ConnFail", verror.NoRetry, "{1:}{2:} connection to peer failed{:_}")
	ErrBrokenCrConnection  = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.BrokenCrConnection", verror.NoRetry, "{1:}{2:} CrConnection stream to client does not exist or is broken")
	ErrDbOffline           = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.DbOffline", verror.NoRetry, "{1:}{2:} database {3} in app {4} is offline and cannot be synced{:_}")
	ErrGetTimeFailed       = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.GetTimeFailed", verror.NoRetry, "{1:}{2:} GetTime failed{:_}")
	ErrNotAdmin            = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.NotAdmin", verror.NoRetry, "{1:}{2:} not an admin of the syncgroup")
)

func init() {
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrDupSyncgroupPublish.ID), "{1:}{2:} duplicate publish on syncgroup: {3}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrConnFail.ID), "{1:}{2:} connection to peer failed{:_}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrBrokenCrConnection.ID), "{1:}{2:} CrConnection stream to client does not exist or is broken")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrDbOffline.ID), "{1:}{2:} database {3} in app {4} is offline and cannot be synced{:_}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrGetTimeFailed.ID), "{1:}{2:} GetTime failed{:_}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrNotAdmin.ID), "{1:}{2:} not an admin of the syncgroup")
}

// NewErrDupSyncgroupPublish returns an error with the ErrDupSyncgroupPublish ID.
func NewErrDupSyncgroupPublish(ctx *context.T, name string) error {
	return verror.New(ErrDupSyncgroupPublish, ctx, name)
}

// NewErrConnFail returns an error with the ErrConnFail ID.
func NewErrConnFail(ctx *context.T) error {
	return verror.New(ErrConnFail, ctx)
}

// NewErrBrokenCrConnection returns an error with the ErrBrokenCrConnection ID.
func NewErrBrokenCrConnection(ctx *context.T) error {
	return verror.New(ErrBrokenCrConnection, ctx)
}

// NewErrDbOffline returns an error with the ErrDbOffline ID.
func NewErrDbOffline(ctx *context.T, dbName string, appName string) error {
	return verror.New(ErrDbOffline, ctx, dbName, appName)
}

// NewErrGetTimeFailed returns an error with the ErrGetTimeFailed ID.
func NewErrGetTimeFailed(ctx *context.T) error {
	return verror.New(ErrGetTimeFailed, ctx)
}

// NewErrNotAdmin returns an error with the ErrNotAdmin ID.
func NewErrNotAdmin(ctx *context.T) error {
	return verror.New(ErrNotAdmin, ctx)
}

// SyncClientMethods is the client interface
// containing Sync methods.
//
// Sync defines methods for data exchange between Syncbases.
// TODO(hpucha): Flesh this out further.
type SyncClientMethods interface {
	// GetTime returns metadata related to the Syncbase virtual clock, including
	// system clock values, last NTP timestamp, num reboots, etc.
	GetTime(_ *context.T, req TimeReq, initiator string, _ ...rpc.CallOpt) (TimeResp, error)
	// GetDeltas returns the responder's current generation vectors and all
	// the missing log records when compared to the initiator's generation
	// vectors for one Database for either syncgroup metadata or data.
	GetDeltas(_ *context.T, req DeltaReq, initiator string, _ ...rpc.CallOpt) (SyncGetDeltasClientCall, error)
	// PublishSyncgroup is invoked on the syncgroup name (typically served
	// by a "central" peer) to publish the syncgroup.  It takes the name of
	// Syncbase doing the publishing (the publisher) and returns the name
	// of the Syncbase where the syncgroup is published (the publishee).
	// This allows the publisher and the publishee to learn of each other.
	// When a syncgroup is published, the publishee is given the syncgroup
	// metadata, its current version at the publisher, and the current
	// syncgroup generation vector.  The generation vector serves as a
	// checkpoint at the time of publishing.  The publishing proceeds
	// asynchronously, and the publishee learns the syncgroup history
	// through the routine p2p sync process and determines when it has
	// caught up to the level of knowledge at the time of publishing using
	// the checkpointed generation vector.  Until that point, the publishee
	// locally deems the syncgroup to be in a pending state and does not
	// mutate it.  Thus it locally rejects syncgroup joins or updates to
	// its spec until it is caught up on the syncgroup history.
	PublishSyncgroup(_ *context.T, publisher string, sg Syncgroup, version string, genvec GenVector, _ ...rpc.CallOpt) (string, error)
	// JoinSyncgroupAtAdmin is invoked by a prospective syncgroup member's
	// Syncbase on a syncgroup admin. It checks whether the requestor is
	// allowed to join the named syncgroup, and if so, adds the requestor to
	// the syncgroup.  It returns a copy of the updated syncgroup metadata,
	// its version, and the syncgroup generation vector at the time of the
	// join.  Similar to the PublishSyncgroup scenario, the joiner at that
	// point does not have the syncgroup history and locally deems it to be
	// in a pending state and does not mutate it.  This means it rejects
	// local updates to the syncgroup spec or, if it were also an admin on
	// the syncgroup, it would reject syncgroup joins until it is caught up
	// on the syncgroup history through p2p sync.
	JoinSyncgroupAtAdmin(_ *context.T, sgName string, joinerName string, myInfo nosql.SyncgroupMemberInfo, _ ...rpc.CallOpt) (sg Syncgroup, version string, genvec GenVector, _ error)
	// HaveBlob verifies that the peer has the requested blob, and if
	// present, returns its size.
	HaveBlob(_ *context.T, br nosql.BlobRef, _ ...rpc.CallOpt) (int64, error)
	// FetchBlob fetches the requested blob.
	FetchBlob(_ *context.T, br nosql.BlobRef, _ ...rpc.CallOpt) (SyncFetchBlobClientCall, error)
	// Methods for incremental blob transfer. The transfer starts with the
	// receiver making a FetchBlobRecipe call to the sender for a given
	// BlobRef. The sender, in turn, sends the chunk hashes of all the
	// chunks that make up the requested blob (blob recipe). The receiver
	// looks up the chunk hashes in its local blob store, and identifies the
	// missing ones. The receiver then fetches the missing chunks using a
	// FetchChunks call from the sender. Finally, the receiver finishes the
	// blob fetch by combining the chunks obtained over the network with the
	// already available local chunks as per the blob recipe.
	FetchBlobRecipe(_ *context.T, br nosql.BlobRef, _ ...rpc.CallOpt) (SyncFetchBlobRecipeClientCall, error)
	FetchChunks(*context.T, ...rpc.CallOpt) (SyncFetchChunksClientCall, error)
}

// SyncClientStub adds universal methods to SyncClientMethods.
type SyncClientStub interface {
	SyncClientMethods
	rpc.UniversalServiceMethods
}

// SyncClient returns a client stub for Sync.
func SyncClient(name string) SyncClientStub {
	return implSyncClientStub{name}
}

type implSyncClientStub struct {
	name string
}

func (c implSyncClientStub) GetTime(ctx *context.T, i0 TimeReq, i1 string, opts ...rpc.CallOpt) (o0 TimeResp, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "GetTime", []interface{}{i0, i1}, []interface{}{&o0}, opts...)
	return
}

func (c implSyncClientStub) GetDeltas(ctx *context.T, i0 DeltaReq, i1 string, opts ...rpc.CallOpt) (ocall SyncGetDeltasClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "GetDeltas", []interface{}{i0, i1}, opts...); err != nil {
		return
	}
	ocall = &implSyncGetDeltasClientCall{ClientCall: call}
	return
}

func (c implSyncClientStub) PublishSyncgroup(ctx *context.T, i0 string, i1 Syncgroup, i2 string, i3 GenVector, opts ...rpc.CallOpt) (o0 string, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "PublishSyncgroup", []interface{}{i0, i1, i2, i3}, []interface{}{&o0}, opts...)
	return
}

func (c implSyncClientStub) JoinSyncgroupAtAdmin(ctx *context.T, i0 string, i1 string, i2 nosql.SyncgroupMemberInfo, opts ...rpc.CallOpt) (o0 Syncgroup, o1 string, o2 GenVector, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "JoinSyncgroupAtAdmin", []interface{}{i0, i1, i2}, []interface{}{&o0, &o1, &o2}, opts...)
	return
}

func (c implSyncClientStub) HaveBlob(ctx *context.T, i0 nosql.BlobRef, opts ...rpc.CallOpt) (o0 int64, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "HaveBlob", []interface{}{i0}, []interface{}{&o0}, opts...)
	return
}

func (c implSyncClientStub) FetchBlob(ctx *context.T, i0 nosql.BlobRef, opts ...rpc.CallOpt) (ocall SyncFetchBlobClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "FetchBlob", []interface{}{i0}, opts...); err != nil {
		return
	}
	ocall = &implSyncFetchBlobClientCall{ClientCall: call}
	return
}

func (c implSyncClientStub) FetchBlobRecipe(ctx *context.T, i0 nosql.BlobRef, opts ...rpc.CallOpt) (ocall SyncFetchBlobRecipeClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "FetchBlobRecipe", []interface{}{i0}, opts...); err != nil {
		return
	}
	ocall = &implSyncFetchBlobRecipeClientCall{ClientCall: call}
	return
}

func (c implSyncClientStub) FetchChunks(ctx *context.T, opts ...rpc.CallOpt) (ocall SyncFetchChunksClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "FetchChunks", nil, opts...); err != nil {
		return
	}
	ocall = &implSyncFetchChunksClientCall{ClientCall: call}
	return
}

// SyncGetDeltasClientStream is the client stream for Sync.GetDeltas.
type SyncGetDeltasClientStream interface {
	// RecvStream returns the receiver side of the Sync.GetDeltas client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() DeltaResp
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// SyncGetDeltasClientCall represents the call returned from Sync.GetDeltas.
type SyncGetDeltasClientCall interface {
	SyncGetDeltasClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implSyncGetDeltasClientCall struct {
	rpc.ClientCall
	valRecv DeltaResp
	errRecv error
}

func (c *implSyncGetDeltasClientCall) RecvStream() interface {
	Advance() bool
	Value() DeltaResp
	Err() error
} {
	return implSyncGetDeltasClientCallRecv{c}
}

type implSyncGetDeltasClientCallRecv struct {
	c *implSyncGetDeltasClientCall
}

func (c implSyncGetDeltasClientCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implSyncGetDeltasClientCallRecv) Value() DeltaResp {
	return c.c.valRecv
}
func (c implSyncGetDeltasClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implSyncGetDeltasClientCall) Finish() (err error) {
	err = c.ClientCall.Finish()
	return
}

// SyncFetchBlobClientStream is the client stream for Sync.FetchBlob.
type SyncFetchBlobClientStream interface {
	// RecvStream returns the receiver side of the Sync.FetchBlob client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() []byte
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// SyncFetchBlobClientCall represents the call returned from Sync.FetchBlob.
type SyncFetchBlobClientCall interface {
	SyncFetchBlobClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implSyncFetchBlobClientCall struct {
	rpc.ClientCall
	valRecv []byte
	errRecv error
}

func (c *implSyncFetchBlobClientCall) RecvStream() interface {
	Advance() bool
	Value() []byte
	Err() error
} {
	return implSyncFetchBlobClientCallRecv{c}
}

type implSyncFetchBlobClientCallRecv struct {
	c *implSyncFetchBlobClientCall
}

func (c implSyncFetchBlobClientCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implSyncFetchBlobClientCallRecv) Value() []byte {
	return c.c.valRecv
}
func (c implSyncFetchBlobClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implSyncFetchBlobClientCall) Finish() (err error) {
	err = c.ClientCall.Finish()
	return
}

// SyncFetchBlobRecipeClientStream is the client stream for Sync.FetchBlobRecipe.
type SyncFetchBlobRecipeClientStream interface {
	// RecvStream returns the receiver side of the Sync.FetchBlobRecipe client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() ChunkHash
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// SyncFetchBlobRecipeClientCall represents the call returned from Sync.FetchBlobRecipe.
type SyncFetchBlobRecipeClientCall interface {
	SyncFetchBlobRecipeClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implSyncFetchBlobRecipeClientCall struct {
	rpc.ClientCall
	valRecv ChunkHash
	errRecv error
}

func (c *implSyncFetchBlobRecipeClientCall) RecvStream() interface {
	Advance() bool
	Value() ChunkHash
	Err() error
} {
	return implSyncFetchBlobRecipeClientCallRecv{c}
}

type implSyncFetchBlobRecipeClientCallRecv struct {
	c *implSyncFetchBlobRecipeClientCall
}

func (c implSyncFetchBlobRecipeClientCallRecv) Advance() bool {
	c.c.valRecv = ChunkHash{}
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implSyncFetchBlobRecipeClientCallRecv) Value() ChunkHash {
	return c.c.valRecv
}
func (c implSyncFetchBlobRecipeClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implSyncFetchBlobRecipeClientCall) Finish() (err error) {
	err = c.ClientCall.Finish()
	return
}

// SyncFetchChunksClientStream is the client stream for Sync.FetchChunks.
type SyncFetchChunksClientStream interface {
	// RecvStream returns the receiver side of the Sync.FetchChunks client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() ChunkData
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the Sync.FetchChunks client stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors
		// encountered while sending, or if Send is called after Close or
		// the stream has been canceled.  Blocks if there is no buffer
		// space; will unblock when buffer space is available or after
		// the stream has been canceled.
		Send(item ChunkHash) error
		// Close indicates to the server that no more items will be sent;
		// server Recv calls will receive io.EOF after all sent items.
		// This is an optional call - e.g. a client might call Close if it
		// needs to continue receiving items from the server after it's
		// done sending.  Returns errors encountered while closing, or if
		// Close is called after the stream has been canceled.  Like Send,
		// blocks if there is no buffer space available.
		Close() error
	}
}

// SyncFetchChunksClientCall represents the call returned from Sync.FetchChunks.
type SyncFetchChunksClientCall interface {
	SyncFetchChunksClientStream
	// Finish performs the equivalent of SendStream().Close, then blocks until
	// the server is done, and returns the positional return values for the call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implSyncFetchChunksClientCall struct {
	rpc.ClientCall
	valRecv ChunkData
	errRecv error
}

func (c *implSyncFetchChunksClientCall) RecvStream() interface {
	Advance() bool
	Value() ChunkData
	Err() error
} {
	return implSyncFetchChunksClientCallRecv{c}
}

type implSyncFetchChunksClientCallRecv struct {
	c *implSyncFetchChunksClientCall
}

func (c implSyncFetchChunksClientCallRecv) Advance() bool {
	c.c.valRecv = ChunkData{}
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implSyncFetchChunksClientCallRecv) Value() ChunkData {
	return c.c.valRecv
}
func (c implSyncFetchChunksClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implSyncFetchChunksClientCall) SendStream() interface {
	Send(item ChunkHash) error
	Close() error
} {
	return implSyncFetchChunksClientCallSend{c}
}

type implSyncFetchChunksClientCallSend struct {
	c *implSyncFetchChunksClientCall
}

func (c implSyncFetchChunksClientCallSend) Send(item ChunkHash) error {
	return c.c.Send(item)
}
func (c implSyncFetchChunksClientCallSend) Close() error {
	return c.c.CloseSend()
}
func (c *implSyncFetchChunksClientCall) Finish() (err error) {
	err = c.ClientCall.Finish()
	return
}

// SyncServerMethods is the interface a server writer
// implements for Sync.
//
// Sync defines methods for data exchange between Syncbases.
// TODO(hpucha): Flesh this out further.
type SyncServerMethods interface {
	// GetTime returns metadata related to the Syncbase virtual clock, including
	// system clock values, last NTP timestamp, num reboots, etc.
	GetTime(_ *context.T, _ rpc.ServerCall, req TimeReq, initiator string) (TimeResp, error)
	// GetDeltas returns the responder's current generation vectors and all
	// the missing log records when compared to the initiator's generation
	// vectors for one Database for either syncgroup metadata or data.
	GetDeltas(_ *context.T, _ SyncGetDeltasServerCall, req DeltaReq, initiator string) error
	// PublishSyncgroup is invoked on the syncgroup name (typically served
	// by a "central" peer) to publish the syncgroup.  It takes the name of
	// Syncbase doing the publishing (the publisher) and returns the name
	// of the Syncbase where the syncgroup is published (the publishee).
	// This allows the publisher and the publishee to learn of each other.
	// When a syncgroup is published, the publishee is given the syncgroup
	// metadata, its current version at the publisher, and the current
	// syncgroup generation vector.  The generation vector serves as a
	// checkpoint at the time of publishing.  The publishing proceeds
	// asynchronously, and the publishee learns the syncgroup history
	// through the routine p2p sync process and determines when it has
	// caught up to the level of knowledge at the time of publishing using
	// the checkpointed generation vector.  Until that point, the publishee
	// locally deems the syncgroup to be in a pending state and does not
	// mutate it.  Thus it locally rejects syncgroup joins or updates to
	// its spec until it is caught up on the syncgroup history.
	PublishSyncgroup(_ *context.T, _ rpc.ServerCall, publisher string, sg Syncgroup, version string, genvec GenVector) (string, error)
	// JoinSyncgroupAtAdmin is invoked by a prospective syncgroup member's
	// Syncbase on a syncgroup admin. It checks whether the requestor is
	// allowed to join the named syncgroup, and if so, adds the requestor to
	// the syncgroup.  It returns a copy of the updated syncgroup metadata,
	// its version, and the syncgroup generation vector at the time of the
	// join.  Similar to the PublishSyncgroup scenario, the joiner at that
	// point does not have the syncgroup history and locally deems it to be
	// in a pending state and does not mutate it.  This means it rejects
	// local updates to the syncgroup spec or, if it were also an admin on
	// the syncgroup, it would reject syncgroup joins until it is caught up
	// on the syncgroup history through p2p sync.
	JoinSyncgroupAtAdmin(_ *context.T, _ rpc.ServerCall, sgName string, joinerName string, myInfo nosql.SyncgroupMemberInfo) (sg Syncgroup, version string, genvec GenVector, _ error)
	// HaveBlob verifies that the peer has the requested blob, and if
	// present, returns its size.
	HaveBlob(_ *context.T, _ rpc.ServerCall, br nosql.BlobRef) (int64, error)
	// FetchBlob fetches the requested blob.
	FetchBlob(_ *context.T, _ SyncFetchBlobServerCall, br nosql.BlobRef) error
	// Methods for incremental blob transfer. The transfer starts with the
	// receiver making a FetchBlobRecipe call to the sender for a given
	// BlobRef. The sender, in turn, sends the chunk hashes of all the
	// chunks that make up the requested blob (blob recipe). The receiver
	// looks up the chunk hashes in its local blob store, and identifies the
	// missing ones. The receiver then fetches the missing chunks using a
	// FetchChunks call from the sender. Finally, the receiver finishes the
	// blob fetch by combining the chunks obtained over the network with the
	// already available local chunks as per the blob recipe.
	FetchBlobRecipe(_ *context.T, _ SyncFetchBlobRecipeServerCall, br nosql.BlobRef) error
	FetchChunks(*context.T, SyncFetchChunksServerCall) error
}

// SyncServerStubMethods is the server interface containing
// Sync methods, as expected by rpc.Server.
// The only difference between this interface and SyncServerMethods
// is the streaming methods.
type SyncServerStubMethods interface {
	// GetTime returns metadata related to the Syncbase virtual clock, including
	// system clock values, last NTP timestamp, num reboots, etc.
	GetTime(_ *context.T, _ rpc.ServerCall, req TimeReq, initiator string) (TimeResp, error)
	// GetDeltas returns the responder's current generation vectors and all
	// the missing log records when compared to the initiator's generation
	// vectors for one Database for either syncgroup metadata or data.
	GetDeltas(_ *context.T, _ *SyncGetDeltasServerCallStub, req DeltaReq, initiator string) error
	// PublishSyncgroup is invoked on the syncgroup name (typically served
	// by a "central" peer) to publish the syncgroup.  It takes the name of
	// Syncbase doing the publishing (the publisher) and returns the name
	// of the Syncbase where the syncgroup is published (the publishee).
	// This allows the publisher and the publishee to learn of each other.
	// When a syncgroup is published, the publishee is given the syncgroup
	// metadata, its current version at the publisher, and the current
	// syncgroup generation vector.  The generation vector serves as a
	// checkpoint at the time of publishing.  The publishing proceeds
	// asynchronously, and the publishee learns the syncgroup history
	// through the routine p2p sync process and determines when it has
	// caught up to the level of knowledge at the time of publishing using
	// the checkpointed generation vector.  Until that point, the publishee
	// locally deems the syncgroup to be in a pending state and does not
	// mutate it.  Thus it locally rejects syncgroup joins or updates to
	// its spec until it is caught up on the syncgroup history.
	PublishSyncgroup(_ *context.T, _ rpc.ServerCall, publisher string, sg Syncgroup, version string, genvec GenVector) (string, error)
	// JoinSyncgroupAtAdmin is invoked by a prospective syncgroup member's
	// Syncbase on a syncgroup admin. It checks whether the requestor is
	// allowed to join the named syncgroup, and if so, adds the requestor to
	// the syncgroup.  It returns a copy of the updated syncgroup metadata,
	// its version, and the syncgroup generation vector at the time of the
	// join.  Similar to the PublishSyncgroup scenario, the joiner at that
	// point does not have the syncgroup history and locally deems it to be
	// in a pending state and does not mutate it.  This means it rejects
	// local updates to the syncgroup spec or, if it were also an admin on
	// the syncgroup, it would reject syncgroup joins until it is caught up
	// on the syncgroup history through p2p sync.
	JoinSyncgroupAtAdmin(_ *context.T, _ rpc.ServerCall, sgName string, joinerName string, myInfo nosql.SyncgroupMemberInfo) (sg Syncgroup, version string, genvec GenVector, _ error)
	// HaveBlob verifies that the peer has the requested blob, and if
	// present, returns its size.
	HaveBlob(_ *context.T, _ rpc.ServerCall, br nosql.BlobRef) (int64, error)
	// FetchBlob fetches the requested blob.
	FetchBlob(_ *context.T, _ *SyncFetchBlobServerCallStub, br nosql.BlobRef) error
	// Methods for incremental blob transfer. The transfer starts with the
	// receiver making a FetchBlobRecipe call to the sender for a given
	// BlobRef. The sender, in turn, sends the chunk hashes of all the
	// chunks that make up the requested blob (blob recipe). The receiver
	// looks up the chunk hashes in its local blob store, and identifies the
	// missing ones. The receiver then fetches the missing chunks using a
	// FetchChunks call from the sender. Finally, the receiver finishes the
	// blob fetch by combining the chunks obtained over the network with the
	// already available local chunks as per the blob recipe.
	FetchBlobRecipe(_ *context.T, _ *SyncFetchBlobRecipeServerCallStub, br nosql.BlobRef) error
	FetchChunks(*context.T, *SyncFetchChunksServerCallStub) error
}

// SyncServerStub adds universal methods to SyncServerStubMethods.
type SyncServerStub interface {
	SyncServerStubMethods
	// Describe the Sync interfaces.
	Describe__() []rpc.InterfaceDesc
}

// SyncServer returns a server stub for Sync.
// It converts an implementation of SyncServerMethods into
// an object that may be used by rpc.Server.
func SyncServer(impl SyncServerMethods) SyncServerStub {
	stub := implSyncServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implSyncServerStub struct {
	impl SyncServerMethods
	gs   *rpc.GlobState
}

func (s implSyncServerStub) GetTime(ctx *context.T, call rpc.ServerCall, i0 TimeReq, i1 string) (TimeResp, error) {
	return s.impl.GetTime(ctx, call, i0, i1)
}

func (s implSyncServerStub) GetDeltas(ctx *context.T, call *SyncGetDeltasServerCallStub, i0 DeltaReq, i1 string) error {
	return s.impl.GetDeltas(ctx, call, i0, i1)
}

func (s implSyncServerStub) PublishSyncgroup(ctx *context.T, call rpc.ServerCall, i0 string, i1 Syncgroup, i2 string, i3 GenVector) (string, error) {
	return s.impl.PublishSyncgroup(ctx, call, i0, i1, i2, i3)
}

func (s implSyncServerStub) JoinSyncgroupAtAdmin(ctx *context.T, call rpc.ServerCall, i0 string, i1 string, i2 nosql.SyncgroupMemberInfo) (Syncgroup, string, GenVector, error) {
	return s.impl.JoinSyncgroupAtAdmin(ctx, call, i0, i1, i2)
}

func (s implSyncServerStub) HaveBlob(ctx *context.T, call rpc.ServerCall, i0 nosql.BlobRef) (int64, error) {
	return s.impl.HaveBlob(ctx, call, i0)
}

func (s implSyncServerStub) FetchBlob(ctx *context.T, call *SyncFetchBlobServerCallStub, i0 nosql.BlobRef) error {
	return s.impl.FetchBlob(ctx, call, i0)
}

func (s implSyncServerStub) FetchBlobRecipe(ctx *context.T, call *SyncFetchBlobRecipeServerCallStub, i0 nosql.BlobRef) error {
	return s.impl.FetchBlobRecipe(ctx, call, i0)
}

func (s implSyncServerStub) FetchChunks(ctx *context.T, call *SyncFetchChunksServerCallStub) error {
	return s.impl.FetchChunks(ctx, call)
}

func (s implSyncServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implSyncServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{SyncDesc}
}

// SyncDesc describes the Sync interface.
var SyncDesc rpc.InterfaceDesc = descSync

// descSync hides the desc to keep godoc clean.
var descSync = rpc.InterfaceDesc{
	Name:    "Sync",
	PkgPath: "v.io/x/ref/services/syncbase/server/interfaces",
	Doc:     "// Sync defines methods for data exchange between Syncbases.\n// TODO(hpucha): Flesh this out further.",
	Methods: []rpc.MethodDesc{
		{
			Name: "GetTime",
			Doc:  "// GetTime returns metadata related to the Syncbase virtual clock, including\n// system clock values, last NTP timestamp, num reboots, etc.",
			InArgs: []rpc.ArgDesc{
				{"req", ``},       // TimeReq
				{"initiator", ``}, // string
			},
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // TimeResp
			},
		},
		{
			Name: "GetDeltas",
			Doc:  "// GetDeltas returns the responder's current generation vectors and all\n// the missing log records when compared to the initiator's generation\n// vectors for one Database for either syncgroup metadata or data.",
			InArgs: []rpc.ArgDesc{
				{"req", ``},       // DeltaReq
				{"initiator", ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Read"))},
		},
		{
			Name: "PublishSyncgroup",
			Doc:  "// PublishSyncgroup is invoked on the syncgroup name (typically served\n// by a \"central\" peer) to publish the syncgroup.  It takes the name of\n// Syncbase doing the publishing (the publisher) and returns the name\n// of the Syncbase where the syncgroup is published (the publishee).\n// This allows the publisher and the publishee to learn of each other.\n// When a syncgroup is published, the publishee is given the syncgroup\n// metadata, its current version at the publisher, and the current\n// syncgroup generation vector.  The generation vector serves as a\n// checkpoint at the time of publishing.  The publishing proceeds\n// asynchronously, and the publishee learns the syncgroup history\n// through the routine p2p sync process and determines when it has\n// caught up to the level of knowledge at the time of publishing using\n// the checkpointed generation vector.  Until that point, the publishee\n// locally deems the syncgroup to be in a pending state and does not\n// mutate it.  Thus it locally rejects syncgroup joins or updates to\n// its spec until it is caught up on the syncgroup history.",
			InArgs: []rpc.ArgDesc{
				{"publisher", ``}, // string
				{"sg", ``},        // Syncgroup
				{"version", ``},   // string
				{"genvec", ``},    // GenVector
			},
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Write"))},
		},
		{
			Name: "JoinSyncgroupAtAdmin",
			Doc:  "// JoinSyncgroupAtAdmin is invoked by a prospective syncgroup member's\n// Syncbase on a syncgroup admin. It checks whether the requestor is\n// allowed to join the named syncgroup, and if so, adds the requestor to\n// the syncgroup.  It returns a copy of the updated syncgroup metadata,\n// its version, and the syncgroup generation vector at the time of the\n// join.  Similar to the PublishSyncgroup scenario, the joiner at that\n// point does not have the syncgroup history and locally deems it to be\n// in a pending state and does not mutate it.  This means it rejects\n// local updates to the syncgroup spec or, if it were also an admin on\n// the syncgroup, it would reject syncgroup joins until it is caught up\n// on the syncgroup history through p2p sync.",
			InArgs: []rpc.ArgDesc{
				{"sgName", ``},     // string
				{"joinerName", ``}, // string
				{"myInfo", ``},     // nosql.SyncgroupMemberInfo
			},
			OutArgs: []rpc.ArgDesc{
				{"sg", ``},      // Syncgroup
				{"version", ``}, // string
				{"genvec", ``},  // GenVector
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Read"))},
		},
		{
			Name: "HaveBlob",
			Doc:  "// HaveBlob verifies that the peer has the requested blob, and if\n// present, returns its size.",
			InArgs: []rpc.ArgDesc{
				{"br", ``}, // nosql.BlobRef
			},
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // int64
			},
		},
		{
			Name: "FetchBlob",
			Doc:  "// FetchBlob fetches the requested blob.",
			InArgs: []rpc.ArgDesc{
				{"br", ``}, // nosql.BlobRef
			},
		},
		{
			Name: "FetchBlobRecipe",
			Doc:  "// Methods for incremental blob transfer. The transfer starts with the\n// receiver making a FetchBlobRecipe call to the sender for a given\n// BlobRef. The sender, in turn, sends the chunk hashes of all the\n// chunks that make up the requested blob (blob recipe). The receiver\n// looks up the chunk hashes in its local blob store, and identifies the\n// missing ones. The receiver then fetches the missing chunks using a\n// FetchChunks call from the sender. Finally, the receiver finishes the\n// blob fetch by combining the chunks obtained over the network with the\n// already available local chunks as per the blob recipe.",
			InArgs: []rpc.ArgDesc{
				{"br", ``}, // nosql.BlobRef
			},
		},
		{
			Name: "FetchChunks",
		},
	},
}

// SyncGetDeltasServerStream is the server stream for Sync.GetDeltas.
type SyncGetDeltasServerStream interface {
	// SendStream returns the send side of the Sync.GetDeltas server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item DeltaResp) error
	}
}

// SyncGetDeltasServerCall represents the context passed to Sync.GetDeltas.
type SyncGetDeltasServerCall interface {
	rpc.ServerCall
	SyncGetDeltasServerStream
}

// SyncGetDeltasServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements SyncGetDeltasServerCall.
type SyncGetDeltasServerCallStub struct {
	rpc.StreamServerCall
}

// Init initializes SyncGetDeltasServerCallStub from rpc.StreamServerCall.
func (s *SyncGetDeltasServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// SendStream returns the send side of the Sync.GetDeltas server stream.
func (s *SyncGetDeltasServerCallStub) SendStream() interface {
	Send(item DeltaResp) error
} {
	return implSyncGetDeltasServerCallSend{s}
}

type implSyncGetDeltasServerCallSend struct {
	s *SyncGetDeltasServerCallStub
}

func (s implSyncGetDeltasServerCallSend) Send(item DeltaResp) error {
	return s.s.Send(item)
}

// SyncFetchBlobServerStream is the server stream for Sync.FetchBlob.
type SyncFetchBlobServerStream interface {
	// SendStream returns the send side of the Sync.FetchBlob server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item []byte) error
	}
}

// SyncFetchBlobServerCall represents the context passed to Sync.FetchBlob.
type SyncFetchBlobServerCall interface {
	rpc.ServerCall
	SyncFetchBlobServerStream
}

// SyncFetchBlobServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements SyncFetchBlobServerCall.
type SyncFetchBlobServerCallStub struct {
	rpc.StreamServerCall
}

// Init initializes SyncFetchBlobServerCallStub from rpc.StreamServerCall.
func (s *SyncFetchBlobServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// SendStream returns the send side of the Sync.FetchBlob server stream.
func (s *SyncFetchBlobServerCallStub) SendStream() interface {
	Send(item []byte) error
} {
	return implSyncFetchBlobServerCallSend{s}
}

type implSyncFetchBlobServerCallSend struct {
	s *SyncFetchBlobServerCallStub
}

func (s implSyncFetchBlobServerCallSend) Send(item []byte) error {
	return s.s.Send(item)
}

// SyncFetchBlobRecipeServerStream is the server stream for Sync.FetchBlobRecipe.
type SyncFetchBlobRecipeServerStream interface {
	// SendStream returns the send side of the Sync.FetchBlobRecipe server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item ChunkHash) error
	}
}

// SyncFetchBlobRecipeServerCall represents the context passed to Sync.FetchBlobRecipe.
type SyncFetchBlobRecipeServerCall interface {
	rpc.ServerCall
	SyncFetchBlobRecipeServerStream
}

// SyncFetchBlobRecipeServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements SyncFetchBlobRecipeServerCall.
type SyncFetchBlobRecipeServerCallStub struct {
	rpc.StreamServerCall
}

// Init initializes SyncFetchBlobRecipeServerCallStub from rpc.StreamServerCall.
func (s *SyncFetchBlobRecipeServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// SendStream returns the send side of the Sync.FetchBlobRecipe server stream.
func (s *SyncFetchBlobRecipeServerCallStub) SendStream() interface {
	Send(item ChunkHash) error
} {
	return implSyncFetchBlobRecipeServerCallSend{s}
}

type implSyncFetchBlobRecipeServerCallSend struct {
	s *SyncFetchBlobRecipeServerCallStub
}

func (s implSyncFetchBlobRecipeServerCallSend) Send(item ChunkHash) error {
	return s.s.Send(item)
}

// SyncFetchChunksServerStream is the server stream for Sync.FetchChunks.
type SyncFetchChunksServerStream interface {
	// RecvStream returns the receiver side of the Sync.FetchChunks server stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() ChunkHash
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the Sync.FetchChunks server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item ChunkData) error
	}
}

// SyncFetchChunksServerCall represents the context passed to Sync.FetchChunks.
type SyncFetchChunksServerCall interface {
	rpc.ServerCall
	SyncFetchChunksServerStream
}

// SyncFetchChunksServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements SyncFetchChunksServerCall.
type SyncFetchChunksServerCallStub struct {
	rpc.StreamServerCall
	valRecv ChunkHash
	errRecv error
}

// Init initializes SyncFetchChunksServerCallStub from rpc.StreamServerCall.
func (s *SyncFetchChunksServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// RecvStream returns the receiver side of the Sync.FetchChunks server stream.
func (s *SyncFetchChunksServerCallStub) RecvStream() interface {
	Advance() bool
	Value() ChunkHash
	Err() error
} {
	return implSyncFetchChunksServerCallRecv{s}
}

type implSyncFetchChunksServerCallRecv struct {
	s *SyncFetchChunksServerCallStub
}

func (s implSyncFetchChunksServerCallRecv) Advance() bool {
	s.s.valRecv = ChunkHash{}
	s.s.errRecv = s.s.Recv(&s.s.valRecv)
	return s.s.errRecv == nil
}
func (s implSyncFetchChunksServerCallRecv) Value() ChunkHash {
	return s.s.valRecv
}
func (s implSyncFetchChunksServerCallRecv) Err() error {
	if s.s.errRecv == io.EOF {
		return nil
	}
	return s.s.errRecv
}

// SendStream returns the send side of the Sync.FetchChunks server stream.
func (s *SyncFetchChunksServerCallStub) SendStream() interface {
	Send(item ChunkData) error
} {
	return implSyncFetchChunksServerCallSend{s}
}

type implSyncFetchChunksServerCallSend struct {
	s *SyncFetchChunksServerCallStub
}

func (s implSyncFetchChunksServerCallSend) Send(item ChunkData) error {
	return s.s.Send(item)
}
