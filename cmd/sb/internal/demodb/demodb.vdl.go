// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: demodb

package demodb

import (
	"fmt"
	"time"
	"v.io/v23/vdl"
	vdltime "v.io/v23/vdlroot/time"
	"v.io/v23/vom"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

type AddressInfo struct {
	Street string
	City   string
	State  string
	Zip    string
}

func (AddressInfo) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.AddressInfo"`
}) {
}

func (x AddressInfo) VDLIsZero() bool {
	return x == AddressInfo{}
}

func (x AddressInfo) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AddressInfo)(nil)).Elem()); err != nil {
		return err
	}
	if x.Street != "" {
		if err := enc.NextField("Street"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Street); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.City != "" {
		if err := enc.NextField("City"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.City); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.State != "" {
		if err := enc.NextField("State"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.State); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Zip != "" {
		if err := enc.NextField("Zip"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Zip); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AddressInfo) VDLRead(dec vdl.Decoder) error {
	*x = AddressInfo{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Street":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Street, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "City":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.City, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "State":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.State, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Zip":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Zip, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type CreditAgency int

const (
	CreditAgencyEquifax CreditAgency = iota
	CreditAgencyExperian
	CreditAgencyTransUnion
)

// CreditAgencyAll holds all labels for CreditAgency.
var CreditAgencyAll = [...]CreditAgency{CreditAgencyEquifax, CreditAgencyExperian, CreditAgencyTransUnion}

// CreditAgencyFromString creates a CreditAgency from a string label.
func CreditAgencyFromString(label string) (x CreditAgency, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *CreditAgency) Set(label string) error {
	switch label {
	case "Equifax", "equifax":
		*x = CreditAgencyEquifax
		return nil
	case "Experian", "experian":
		*x = CreditAgencyExperian
		return nil
	case "TransUnion", "transunion":
		*x = CreditAgencyTransUnion
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in demodb.CreditAgency", label)
}

// String returns the string label of x.
func (x CreditAgency) String() string {
	switch x {
	case CreditAgencyEquifax:
		return "Equifax"
	case CreditAgencyExperian:
		return "Experian"
	case CreditAgencyTransUnion:
		return "TransUnion"
	}
	return ""
}

func (CreditAgency) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.CreditAgency"`
	Enum struct{ Equifax, Experian, TransUnion string }
}) {
}

func (x CreditAgency) VDLIsZero() bool {
	return x == CreditAgencyEquifax
}

func (x CreditAgency) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*CreditAgency)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *CreditAgency) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type ExperianRating int

const (
	ExperianRatingGood ExperianRating = iota
	ExperianRatingBad
)

// ExperianRatingAll holds all labels for ExperianRating.
var ExperianRatingAll = [...]ExperianRating{ExperianRatingGood, ExperianRatingBad}

// ExperianRatingFromString creates a ExperianRating from a string label.
func ExperianRatingFromString(label string) (x ExperianRating, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ExperianRating) Set(label string) error {
	switch label {
	case "Good", "good":
		*x = ExperianRatingGood
		return nil
	case "Bad", "bad":
		*x = ExperianRatingBad
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in demodb.ExperianRating", label)
}

// String returns the string label of x.
func (x ExperianRating) String() string {
	switch x {
	case ExperianRatingGood:
		return "Good"
	case ExperianRatingBad:
		return "Bad"
	}
	return ""
}

func (ExperianRating) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.ExperianRating"`
	Enum struct{ Good, Bad string }
}) {
}

func (x ExperianRating) VDLIsZero() bool {
	return x == ExperianRatingGood
}

func (x ExperianRating) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ExperianRating)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ExperianRating) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type EquifaxCreditReport struct {
	Rating byte
}

func (EquifaxCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.EquifaxCreditReport"`
}) {
}

func (x EquifaxCreditReport) VDLIsZero() bool {
	return x == EquifaxCreditReport{}
}

func (x EquifaxCreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*EquifaxCreditReport)(nil)).Elem()); err != nil {
		return err
	}
	if x.Rating != 0 {
		if err := enc.NextField("Rating"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Rating)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *EquifaxCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = EquifaxCreditReport{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Rating":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.Rating = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type ExperianCreditReport struct {
	Rating ExperianRating
}

func (ExperianCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.ExperianCreditReport"`
}) {
}

func (x ExperianCreditReport) VDLIsZero() bool {
	return x == ExperianCreditReport{}
}

func (x ExperianCreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ExperianCreditReport)(nil)).Elem()); err != nil {
		return err
	}
	if x.Rating != ExperianRatingGood {
		if err := enc.NextField("Rating"); err != nil {
			return err
		}
		if err := x.Rating.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ExperianCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = ExperianCreditReport{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Rating":
			if err := x.Rating.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type TransUnionCreditReport struct {
	Rating int16
}

func (TransUnionCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.TransUnionCreditReport"`
}) {
}

func (x TransUnionCreditReport) VDLIsZero() bool {
	return x == TransUnionCreditReport{}
}

func (x TransUnionCreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*TransUnionCreditReport)(nil)).Elem()); err != nil {
		return err
	}
	if x.Rating != 0 {
		if err := enc.NextField("Rating"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x.Rating)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *TransUnionCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = TransUnionCreditReport{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Rating":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			x.Rating = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type (
	// AgencyReport represents any single field of the AgencyReport union type.
	AgencyReport interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the AgencyReport union type.
		__VDLReflect(__AgencyReportReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// AgencyReportEquifaxReport represents field EquifaxReport of the AgencyReport union type.
	AgencyReportEquifaxReport struct{ Value EquifaxCreditReport }
	// AgencyReportExperianReport represents field ExperianReport of the AgencyReport union type.
	AgencyReportExperianReport struct{ Value ExperianCreditReport }
	// AgencyReportTransUnionReport represents field TransUnionReport of the AgencyReport union type.
	AgencyReportTransUnionReport struct{ Value TransUnionCreditReport }
	// __AgencyReportReflect describes the AgencyReport union type.
	__AgencyReportReflect struct {
		Name  string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.AgencyReport"`
		Type  AgencyReport
		Union struct {
			EquifaxReport    AgencyReportEquifaxReport
			ExperianReport   AgencyReportExperianReport
			TransUnionReport AgencyReportTransUnionReport
		}
	}
)

func (x AgencyReportEquifaxReport) Index() int                         { return 0 }
func (x AgencyReportEquifaxReport) Interface() interface{}             { return x.Value }
func (x AgencyReportEquifaxReport) Name() string                       { return "EquifaxReport" }
func (x AgencyReportEquifaxReport) __VDLReflect(__AgencyReportReflect) {}

func (x AgencyReportExperianReport) Index() int                         { return 1 }
func (x AgencyReportExperianReport) Interface() interface{}             { return x.Value }
func (x AgencyReportExperianReport) Name() string                       { return "ExperianReport" }
func (x AgencyReportExperianReport) __VDLReflect(__AgencyReportReflect) {}

func (x AgencyReportTransUnionReport) Index() int                         { return 2 }
func (x AgencyReportTransUnionReport) Interface() interface{}             { return x.Value }
func (x AgencyReportTransUnionReport) Name() string                       { return "TransUnionReport" }
func (x AgencyReportTransUnionReport) __VDLReflect(__AgencyReportReflect) {}

func (x AgencyReportEquifaxReport) VDLIsZero() bool {
	return x.Value == EquifaxCreditReport{}
}

func (x AgencyReportExperianReport) VDLIsZero() bool {
	return false
}

func (x AgencyReportTransUnionReport) VDLIsZero() bool {
	return false
}

func (x AgencyReportEquifaxReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AgencyReport)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("EquifaxReport"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x AgencyReportExperianReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AgencyReport)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("ExperianReport"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x AgencyReportTransUnionReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AgencyReport)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("TransUnionReport"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadAgencyReport(dec vdl.Decoder, x *AgencyReport) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "EquifaxReport":
		var field AgencyReportEquifaxReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "ExperianReport":
		var field AgencyReportExperianReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "TransUnionReport":
		var field AgencyReportTransUnionReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type CreditReport struct {
	Agency CreditAgency
	Report AgencyReport
}

func (CreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.CreditReport"`
}) {
}

func (x CreditReport) VDLIsZero() bool {
	if x.Agency != CreditAgencyEquifax {
		return false
	}
	if x.Report != nil && !x.Report.VDLIsZero() {
		return false
	}
	return true
}

func (x CreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*CreditReport)(nil)).Elem()); err != nil {
		return err
	}
	if x.Agency != CreditAgencyEquifax {
		if err := enc.NextField("Agency"); err != nil {
			return err
		}
		if err := x.Agency.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Report != nil && !x.Report.VDLIsZero() {
		if err := enc.NextField("Report"); err != nil {
			return err
		}
		if err := x.Report.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *CreditReport) VDLRead(dec vdl.Decoder) error {
	*x = CreditReport{
		Report: AgencyReportEquifaxReport{},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Agency":
			if err := x.Agency.VDLRead(dec); err != nil {
				return err
			}
		case "Report":
			if err := VDLReadAgencyReport(dec, &x.Report); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Customer struct {
	Name    string
	Id      int64
	Active  bool
	Address AddressInfo
	Credit  CreditReport
}

func (Customer) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.Customer"`
}) {
}

func (x Customer) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if x.Id != 0 {
		return false
	}
	if x.Active {
		return false
	}
	if x.Address != (AddressInfo{}) {
		return false
	}
	if !x.Credit.VDLIsZero() {
		return false
	}
	return true
}

func (x Customer) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Customer)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Id != 0 {
		if err := enc.NextField("Id"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.Id); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Active {
		if err := enc.NextField("Active"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Active); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Address != (AddressInfo{}) {
		if err := enc.NextField("Address"); err != nil {
			return err
		}
		if err := x.Address.VDLWrite(enc); err != nil {
			return err
		}
	}
	if !x.Credit.VDLIsZero() {
		if err := enc.NextField("Credit"); err != nil {
			return err
		}
		if err := x.Credit.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Customer) VDLRead(dec vdl.Decoder) error {
	*x = Customer{
		Credit: CreditReport{
			Report: AgencyReportEquifaxReport{},
		},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Id":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Id, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Active":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Active, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Address":
			if err := x.Address.VDLRead(dec); err != nil {
				return err
			}
		case "Credit":
			if err := x.Credit.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Invoice struct {
	CustId     int64
	InvoiceNum int64
	Amount     int64
	ShipTo     AddressInfo
}

func (Invoice) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.Invoice"`
}) {
}

func (x Invoice) VDLIsZero() bool {
	return x == Invoice{}
}

func (x Invoice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Invoice)(nil)).Elem()); err != nil {
		return err
	}
	if x.CustId != 0 {
		if err := enc.NextField("CustId"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.CustId); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.InvoiceNum != 0 {
		if err := enc.NextField("InvoiceNum"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.InvoiceNum); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Amount != 0 {
		if err := enc.NextField("Amount"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.Amount); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.ShipTo != (AddressInfo{}) {
		if err := enc.NextField("ShipTo"); err != nil {
			return err
		}
		if err := x.ShipTo.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Invoice) VDLRead(dec vdl.Decoder) error {
	*x = Invoice{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "CustId":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.CustId, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "InvoiceNum":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.InvoiceNum, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Amount":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Amount, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "ShipTo":
			if err := x.ShipTo.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Numbers struct {
	B    byte
	Ui16 uint16
	Ui32 uint32
	Ui64 uint64
	I16  int16
	I32  int32
	I64  int64
	F32  float32
	F64  float64
}

func (Numbers) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.Numbers"`
}) {
}

func (x Numbers) VDLIsZero() bool {
	return x == Numbers{}
}

func (x Numbers) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Numbers)(nil)).Elem()); err != nil {
		return err
	}
	if x.B != 0 {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.B)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Ui16 != 0 {
		if err := enc.NextField("Ui16"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint16Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Ui16)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Ui32 != 0 {
		if err := enc.NextField("Ui32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Ui32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Ui64 != 0 {
		if err := enc.NextField("Ui64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(x.Ui64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.I16 != 0 {
		if err := enc.NextField("I16"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x.I16)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.I32 != 0 {
		if err := enc.NextField("I32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int32Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x.I32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.I64 != 0 {
		if err := enc.NextField("I64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.I64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.F32 != 0 {
		if err := enc.NextField("F32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float32Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(float64(x.F32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.F64 != 0 {
		if err := enc.NextField("F64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(x.F64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Numbers) VDLRead(dec vdl.Decoder) error {
	*x = Numbers{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "B":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.B = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Ui16":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			x.Ui16 = uint16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Ui32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			x.Ui32 = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Ui64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Ui64, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "I16":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			x.I16 = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "I32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.I32 = int32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "I64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.I64, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "F32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			x.F32 = float32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "F64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.F64, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type (
	// TitleOrValueType represents any single field of the TitleOrValueType union type.
	TitleOrValueType interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the TitleOrValueType union type.
		__VDLReflect(__TitleOrValueTypeReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// TitleOrValueTypeTitle represents field Title of the TitleOrValueType union type.
	TitleOrValueTypeTitle struct{ Value string }
	// TitleOrValueTypeValue represents field Value of the TitleOrValueType union type.
	TitleOrValueTypeValue struct{ Value int64 }
	// __TitleOrValueTypeReflect describes the TitleOrValueType union type.
	__TitleOrValueTypeReflect struct {
		Name  string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.TitleOrValueType"`
		Type  TitleOrValueType
		Union struct {
			Title TitleOrValueTypeTitle
			Value TitleOrValueTypeValue
		}
	}
)

func (x TitleOrValueTypeTitle) Index() int                             { return 0 }
func (x TitleOrValueTypeTitle) Interface() interface{}                 { return x.Value }
func (x TitleOrValueTypeTitle) Name() string                           { return "Title" }
func (x TitleOrValueTypeTitle) __VDLReflect(__TitleOrValueTypeReflect) {}

func (x TitleOrValueTypeValue) Index() int                             { return 1 }
func (x TitleOrValueTypeValue) Interface() interface{}                 { return x.Value }
func (x TitleOrValueTypeValue) Name() string                           { return "Value" }
func (x TitleOrValueTypeValue) __VDLReflect(__TitleOrValueTypeReflect) {}

func (x TitleOrValueTypeTitle) VDLIsZero() bool {
	return x.Value == ""
}

func (x TitleOrValueTypeValue) VDLIsZero() bool {
	return false
}

func (x TitleOrValueTypeTitle) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*TitleOrValueType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("Title"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.StringType); err != nil {
		return err
	}
	if err := enc.EncodeString(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x TitleOrValueTypeValue) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*TitleOrValueType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("Value"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.Int64Type); err != nil {
		return err
	}
	if err := enc.EncodeInt(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadTitleOrValueType(dec vdl.Decoder, x *TitleOrValueType) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "Title":
		var field TitleOrValueTypeTitle
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "Value":
		var field TitleOrValueTypeValue
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeInt(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type BazType struct {
	Name         string
	TitleOrValue TitleOrValueType
}

func (BazType) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.BazType"`
}) {
}

func (x BazType) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if x.TitleOrValue != nil && !x.TitleOrValue.VDLIsZero() {
		return false
	}
	return true
}

func (x BazType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BazType)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.TitleOrValue != nil && !x.TitleOrValue.VDLIsZero() {
		if err := enc.NextField("TitleOrValue"); err != nil {
			return err
		}
		if err := x.TitleOrValue.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BazType) VDLRead(dec vdl.Decoder) error {
	*x = BazType{
		TitleOrValue: TitleOrValueTypeTitle{},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "TitleOrValue":
			if err := VDLReadTitleOrValueType(dec, &x.TitleOrValue); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type BarType struct {
	Baz BazType
}

func (BarType) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.BarType"`
}) {
}

func (x BarType) VDLIsZero() bool {
	if !x.Baz.VDLIsZero() {
		return false
	}
	return true
}

func (x BarType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BarType)(nil)).Elem()); err != nil {
		return err
	}
	if !x.Baz.VDLIsZero() {
		if err := enc.NextField("Baz"); err != nil {
			return err
		}
		if err := x.Baz.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BarType) VDLRead(dec vdl.Decoder) error {
	*x = BarType{
		Baz: BazType{
			TitleOrValue: TitleOrValueTypeTitle{},
		},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Baz":
			if err := x.Baz.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type FooType struct {
	Bar BarType
}

func (FooType) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.FooType"`
}) {
}

func (x FooType) VDLIsZero() bool {
	if !x.Bar.VDLIsZero() {
		return false
	}
	return true
}

func (x FooType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*FooType)(nil)).Elem()); err != nil {
		return err
	}
	if !x.Bar.VDLIsZero() {
		if err := enc.NextField("Bar"); err != nil {
			return err
		}
		if err := x.Bar.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FooType) VDLRead(dec vdl.Decoder) error {
	*x = FooType{
		Bar: BarType{
			Baz: BazType{
				TitleOrValue: TitleOrValueTypeTitle{},
			},
		},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Bar":
			if err := x.Bar.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Array2String [2]string

func (Array2String) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.Array2String"`
}) {
}

func (x Array2String) VDLIsZero() bool {
	return x == Array2String{}
}

func (x Array2String) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Array2String)(nil))); err != nil {
		return err
	}
	for i := 0; i < 2; i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Array2String) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, done:%v index:%d len:%d %T)", done, index, len(*x), *x)
		case done:
			return dec.FinishValue()
		}
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if x[index], err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		index++
	}
}

type Composite struct {
	Arr     Array2String
	ListInt []int32
	MySet   map[int32]struct{}
	Map     map[string]int32
}

func (Composite) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.Composite"`
}) {
}

func (x Composite) VDLIsZero() bool {
	if x.Arr != (Array2String{}) {
		return false
	}
	if len(x.ListInt) != 0 {
		return false
	}
	if len(x.MySet) != 0 {
		return false
	}
	if len(x.Map) != 0 {
		return false
	}
	return true
}

func (x Composite) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Composite)(nil)).Elem()); err != nil {
		return err
	}
	if x.Arr != (Array2String{}) {
		if err := enc.NextField("Arr"); err != nil {
			return err
		}
		if err := x.Arr.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.ListInt) != 0 {
		if err := enc.NextField("ListInt"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_1(enc, x.ListInt); err != nil {
			return err
		}
	}
	if len(x.MySet) != 0 {
		if err := enc.NextField("MySet"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_2(enc, x.MySet); err != nil {
			return err
		}
	}
	if len(x.Map) != 0 {
		if err := enc.NextField("Map"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_3(enc, x.Map); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_1(enc vdl.Encoder, x []int32) error {
	if err := enc.StartValue(vdl.TypeOf((*[]int32)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int32Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x[i])); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_2(enc vdl.Encoder, x map[int32]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[int32]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int32Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_3(enc vdl.Encoder, x map[string]int32) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string]int32)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int32Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(elem)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Composite) VDLRead(dec vdl.Decoder) error {
	*x = Composite{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Arr":
			if err := x.Arr.VDLRead(dec); err != nil {
				return err
			}
		case "ListInt":
			if err := __VDLReadAnon_list_1(dec, &x.ListInt); err != nil {
				return err
			}
		case "MySet":
			if err := __VDLReadAnon_set_2(dec, &x.MySet); err != nil {
				return err
			}
		case "Map":
			if err := __VDLReadAnon_map_3(dec, &x.Map); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_1(dec vdl.Decoder, x *[]int32) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]int32, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem int32
		if err := dec.StartValue(); err != nil {
			return err
		}
		tmp, err := dec.DecodeInt(32)
		if err != nil {
			return err
		}
		elem = int32(tmp)
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLReadAnon_set_2(dec vdl.Decoder, x *map[int32]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[int32]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int32]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			key = int32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[int32]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_map_3(dec vdl.Decoder, x *map[string]int32) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string]int32
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]int32, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem int32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			elem = int32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string]int32)
		}
		tmpMap[key] = elem
	}
}

type Times struct {
	Stamp    time.Time
	Interval time.Duration
}

func (Times) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.Times"`
}) {
}

func (x Times) VDLIsZero() bool {
	if !x.Stamp.IsZero() {
		return false
	}
	if x.Interval != 0 {
		return false
	}
	return true
}

func (x Times) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Times)(nil)).Elem()); err != nil {
		return err
	}
	if !x.Stamp.IsZero() {
		if err := enc.NextField("Stamp"); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, x.Stamp); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Interval != 0 {
		if err := enc.NextField("Interval"); err != nil {
			return err
		}
		var wire vdltime.Duration
		if err := vdltime.DurationFromNative(&wire, x.Interval); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Times) VDLRead(dec vdl.Decoder) error {
	*x = Times{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Stamp":
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &x.Stamp); err != nil {
				return err
			}
		case "Interval":
			var wire vdltime.Duration
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.DurationToNative(wire, &x.Interval); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Recursive struct {
	Any   *vom.RawBytes
	Maybe *Times
	Rec   map[Array2String]Recursive
}

func (Recursive) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.Recursive"`
}) {
}

func (x Recursive) VDLIsZero() bool {
	if x.Any != nil && !x.Any.VDLIsZero() {
		return false
	}
	if x.Maybe != nil {
		return false
	}
	if len(x.Rec) != 0 {
		return false
	}
	return true
}

func (x Recursive) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Recursive)(nil)).Elem()); err != nil {
		return err
	}
	if x.Any != nil && !x.Any.VDLIsZero() {
		if err := enc.NextField("Any"); err != nil {
			return err
		}
		if err := x.Any.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Maybe != nil {
		if err := enc.NextField("Maybe"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()

		if err := x.Maybe.VDLWrite(enc); err != nil {
			return err
		}

	}
	if len(x.Rec) != 0 {
		if err := enc.NextField("Rec"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_4(enc, x.Rec); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_4(enc vdl.Encoder, x map[Array2String]Recursive) error {
	if err := enc.StartValue(vdl.TypeOf((*map[Array2String]Recursive)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Recursive) VDLRead(dec vdl.Decoder) error {
	*x = Recursive{
		Any: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Any":
			x.Any = new(vom.RawBytes)
			if err := x.Any.VDLRead(dec); err != nil {
				return err
			}
		case "Maybe":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.Maybe), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.Maybe, dec.Type())
				}
				x.Maybe = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.Maybe = new(Times)
				dec.IgnoreNextStartValue()
				if err := x.Maybe.VDLRead(dec); err != nil {
					return err
				}
			}
		case "Rec":
			if err := __VDLReadAnon_map_4(dec, &x.Rec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_4(dec vdl.Decoder, x *map[Array2String]Recursive) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[Array2String]Recursive
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[Array2String]Recursive, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key Array2String
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		var elem Recursive
		{
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[Array2String]Recursive)
		}
		tmpMap[key] = elem
	}
}

type (
	// ActOrSatScore represents any single field of the ActOrSatScore union type.
	ActOrSatScore interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the ActOrSatScore union type.
		__VDLReflect(__ActOrSatScoreReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// ActOrSatScoreActScore represents field ActScore of the ActOrSatScore union type.
	ActOrSatScoreActScore struct{ Value uint16 }
	// ActOrSatScoreSatScore represents field SatScore of the ActOrSatScore union type.
	ActOrSatScoreSatScore struct{ Value uint16 }
	// __ActOrSatScoreReflect describes the ActOrSatScore union type.
	__ActOrSatScoreReflect struct {
		Name  string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.ActOrSatScore"`
		Type  ActOrSatScore
		Union struct {
			ActScore ActOrSatScoreActScore
			SatScore ActOrSatScoreSatScore
		}
	}
)

func (x ActOrSatScoreActScore) Index() int                          { return 0 }
func (x ActOrSatScoreActScore) Interface() interface{}              { return x.Value }
func (x ActOrSatScoreActScore) Name() string                        { return "ActScore" }
func (x ActOrSatScoreActScore) __VDLReflect(__ActOrSatScoreReflect) {}

func (x ActOrSatScoreSatScore) Index() int                          { return 1 }
func (x ActOrSatScoreSatScore) Interface() interface{}              { return x.Value }
func (x ActOrSatScoreSatScore) Name() string                        { return "SatScore" }
func (x ActOrSatScoreSatScore) __VDLReflect(__ActOrSatScoreReflect) {}

func (x ActOrSatScoreActScore) VDLIsZero() bool {
	return x.Value == 0
}

func (x ActOrSatScoreSatScore) VDLIsZero() bool {
	return false
}

func (x ActOrSatScoreActScore) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ActOrSatScore)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("ActScore"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.Uint16Type); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x.Value)); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x ActOrSatScoreSatScore) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ActOrSatScore)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("SatScore"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.Uint16Type); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x.Value)); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadActOrSatScore(dec vdl.Decoder, x *ActOrSatScore) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "ActScore":
		var field ActOrSatScoreActScore
		if err := dec.StartValue(); err != nil {
			return err
		}
		tmp, err := dec.DecodeUint(16)
		if err != nil {
			return err
		}
		field.Value = uint16(tmp)
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "SatScore":
		var field ActOrSatScoreSatScore
		if err := dec.StartValue(); err != nil {
			return err
		}
		tmp, err := dec.DecodeUint(16)
		if err != nil {
			return err
		}
		field.Value = uint16(tmp)
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type Student struct {
	Name     string
	TestTime time.Time
	Score    ActOrSatScore
}

func (Student) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.Student"`
}) {
}

func (x Student) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if !x.TestTime.IsZero() {
		return false
	}
	if x.Score != nil && !x.Score.VDLIsZero() {
		return false
	}
	return true
}

func (x Student) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Student)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if !x.TestTime.IsZero() {
		if err := enc.NextField("TestTime"); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, x.TestTime); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Score != nil && !x.Score.VDLIsZero() {
		if err := enc.NextField("Score"); err != nil {
			return err
		}
		if err := x.Score.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Student) VDLRead(dec vdl.Decoder) error {
	*x = Student{
		Score: ActOrSatScoreActScore{},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "TestTime":
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &x.TestTime); err != nil {
				return err
			}
		case "Score":
			if err := VDLReadActOrSatScore(dec, &x.Score); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type AnythingGoes struct {
	NameOfType string
	Anything   *vom.RawBytes
}

func (AnythingGoes) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/cmd/sb/internal/demodb.AnythingGoes"`
}) {
}

func (x AnythingGoes) VDLIsZero() bool {
	if x.NameOfType != "" {
		return false
	}
	if x.Anything != nil && !x.Anything.VDLIsZero() {
		return false
	}
	return true
}

func (x AnythingGoes) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AnythingGoes)(nil)).Elem()); err != nil {
		return err
	}
	if x.NameOfType != "" {
		if err := enc.NextField("NameOfType"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.NameOfType); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Anything != nil && !x.Anything.VDLIsZero() {
		if err := enc.NextField("Anything"); err != nil {
			return err
		}
		if err := x.Anything.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AnythingGoes) VDLRead(dec vdl.Decoder) error {
	*x = AnythingGoes{
		Anything: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "NameOfType":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.NameOfType, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Anything":
			x.Anything = new(vom.RawBytes)
			if err := x.Anything.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*AddressInfo)(nil))
	vdl.Register((*CreditAgency)(nil))
	vdl.Register((*ExperianRating)(nil))
	vdl.Register((*EquifaxCreditReport)(nil))
	vdl.Register((*ExperianCreditReport)(nil))
	vdl.Register((*TransUnionCreditReport)(nil))
	vdl.Register((*AgencyReport)(nil))
	vdl.Register((*CreditReport)(nil))
	vdl.Register((*Customer)(nil))
	vdl.Register((*Invoice)(nil))
	vdl.Register((*Numbers)(nil))
	vdl.Register((*TitleOrValueType)(nil))
	vdl.Register((*BazType)(nil))
	vdl.Register((*BarType)(nil))
	vdl.Register((*FooType)(nil))
	vdl.Register((*Array2String)(nil))
	vdl.Register((*Composite)(nil))
	vdl.Register((*Times)(nil))
	vdl.Register((*Recursive)(nil))
	vdl.Register((*ActOrSatScore)(nil))
	vdl.Register((*Student)(nil))
	vdl.Register((*AnythingGoes)(nil))

	return struct{}{}
}
