// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: base

// Package base is a simple single-file test of vdl functionality.
package base

import (
	"fmt"
	"io"
	"reflect"
	"v.io/v23"
	"v.io/v23/context"
	"v.io/v23/i18n"
	"v.io/v23/rpc"
	"v.io/v23/vdl"
	"v.io/v23/vdl/vdlconv"
	"v.io/v23/verror"
	"v.io/v23/vom"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

type NamedBool bool

func (NamedBool) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedBool"`
}) {
}

func (m *NamedBool) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBool(bool((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedBool) MakeVDLTarget() vdl.Target {
	return &NamedBoolTarget{Value: m}
}

type NamedBoolTarget struct {
	Value *NamedBool
	vdl.TargetBase
}

func (t *NamedBoolTarget) FromBool(src bool, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NamedBool)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = NamedBool(src)

	return nil
}

func (x *NamedBool) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeBool()
	if err != nil {
		return err
	}
	*x = NamedBool(tmp)
	return dec.FinishValue()
}

type NamedByte byte

func (NamedByte) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedByte"`
}) {
}

func (m *NamedByte) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedByte) MakeVDLTarget() vdl.Target {
	return &NamedByteTarget{Value: m}
}

type NamedByteTarget struct {
	Value *NamedByte
	vdl.TargetBase
}

func (t *NamedByteTarget) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NamedByte(val)

	return nil
}
func (t *NamedByteTarget) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NamedByte(val)

	return nil
}
func (t *NamedByteTarget) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NamedByte(val)

	return nil
}

func (x *NamedByte) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(8)
	if err != nil {
		return err
	}
	*x = NamedByte(tmp)
	return dec.FinishValue()
}

type NamedUint16 uint16

func (NamedUint16) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedUint16"`
}) {
}

func (m *NamedUint16) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedUint16) MakeVDLTarget() vdl.Target {
	return &NamedUint16Target{Value: m}
}

type NamedUint16Target struct {
	Value *NamedUint16
	vdl.TargetBase
}

func (t *NamedUint16Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NamedUint16(val)

	return nil
}
func (t *NamedUint16Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NamedUint16(val)

	return nil
}
func (t *NamedUint16Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NamedUint16(val)

	return nil
}

func (x *NamedUint16) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(16)
	if err != nil {
		return err
	}
	*x = NamedUint16(tmp)
	return dec.FinishValue()
}

type NamedUint32 uint32

func (NamedUint32) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedUint32"`
}) {
}

func (m *NamedUint32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedUint32) MakeVDLTarget() vdl.Target {
	return &NamedUint32Target{Value: m}
}

type NamedUint32Target struct {
	Value *NamedUint32
	vdl.TargetBase
}

func (t *NamedUint32Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NamedUint32(val)

	return nil
}
func (t *NamedUint32Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NamedUint32(val)

	return nil
}
func (t *NamedUint32Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NamedUint32(val)

	return nil
}

func (x *NamedUint32) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(32)
	if err != nil {
		return err
	}
	*x = NamedUint32(tmp)
	return dec.FinishValue()
}

type NamedUint64 uint64

func (NamedUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedUint64"`
}) {
}

func (m *NamedUint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedUint64) MakeVDLTarget() vdl.Target {
	return &NamedUint64Target{Value: m}
}

type NamedUint64Target struct {
	Value *NamedUint64
	vdl.TargetBase
}

func (t *NamedUint64Target) FromUint(src uint64, tt *vdl.Type) error {

	*t.Value = NamedUint64(src)

	return nil
}
func (t *NamedUint64Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = NamedUint64(val)

	return nil
}
func (t *NamedUint64Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = NamedUint64(val)

	return nil
}

func (x *NamedUint64) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(64)
	if err != nil {
		return err
	}
	*x = NamedUint64(tmp)
	return dec.FinishValue()
}

type NamedInt8 int8

func (NamedInt8) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedInt8"`
}) {
}

func (m *NamedInt8) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedInt8) MakeVDLTarget() vdl.Target {
	return &NamedInt8Target{Value: m}
}

type NamedInt8Target struct {
	Value *NamedInt8
	vdl.TargetBase
}

func (t *NamedInt8Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt8(val)

	return nil
}
func (t *NamedInt8Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt8(val)

	return nil
}
func (t *NamedInt8Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt8(val)

	return nil
}

func (x *NamedInt8) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(8)
	if err != nil {
		return err
	}
	*x = NamedInt8(tmp)
	return dec.FinishValue()
}

type NamedInt16 int16

func (NamedInt16) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedInt16"`
}) {
}

func (m *NamedInt16) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedInt16) MakeVDLTarget() vdl.Target {
	return &NamedInt16Target{Value: m}
}

type NamedInt16Target struct {
	Value *NamedInt16
	vdl.TargetBase
}

func (t *NamedInt16Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt16(val)

	return nil
}
func (t *NamedInt16Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt16(val)

	return nil
}
func (t *NamedInt16Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt16(val)

	return nil
}

func (x *NamedInt16) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(16)
	if err != nil {
		return err
	}
	*x = NamedInt16(tmp)
	return dec.FinishValue()
}

type NamedInt32 int32

func (NamedInt32) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedInt32"`
}) {
}

func (m *NamedInt32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedInt32) MakeVDLTarget() vdl.Target {
	return &NamedInt32Target{Value: m}
}

type NamedInt32Target struct {
	Value *NamedInt32
	vdl.TargetBase
}

func (t *NamedInt32Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt32(val)

	return nil
}
func (t *NamedInt32Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt32(val)

	return nil
}
func (t *NamedInt32Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt32(val)

	return nil
}

func (x *NamedInt32) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(32)
	if err != nil {
		return err
	}
	*x = NamedInt32(tmp)
	return dec.FinishValue()
}

type NamedInt64 int64

func (NamedInt64) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedInt64"`
}) {
}

func (m *NamedInt64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedInt64) MakeVDLTarget() vdl.Target {
	return &NamedInt64Target{Value: m}
}

type NamedInt64Target struct {
	Value *NamedInt64
	vdl.TargetBase
}

func (t *NamedInt64Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt64(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt64(val)

	return nil
}
func (t *NamedInt64Target) FromInt(src int64, tt *vdl.Type) error {

	*t.Value = NamedInt64(src)

	return nil
}
func (t *NamedInt64Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt64(src)
	if err != nil {
		return err
	}
	*t.Value = NamedInt64(val)

	return nil
}

func (x *NamedInt64) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(64)
	if err != nil {
		return err
	}
	*x = NamedInt64(tmp)
	return dec.FinishValue()
}

type NamedFloat32 float32

func (NamedFloat32) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedFloat32"`
}) {
}

func (m *NamedFloat32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromFloat(float64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedFloat32) MakeVDLTarget() vdl.Target {
	return &NamedFloat32Target{Value: m}
}

type NamedFloat32Target struct {
	Value *NamedFloat32
	vdl.TargetBase
}

func (t *NamedFloat32Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NamedFloat32(val)

	return nil
}
func (t *NamedFloat32Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NamedFloat32(val)

	return nil
}
func (t *NamedFloat32Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NamedFloat32(val)

	return nil
}

func (x *NamedFloat32) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeFloat(32)
	if err != nil {
		return err
	}
	*x = NamedFloat32(tmp)
	return dec.FinishValue()
}

type NamedFloat64 float64

func (NamedFloat64) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedFloat64"`
}) {
}

func (m *NamedFloat64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromFloat(float64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedFloat64) MakeVDLTarget() vdl.Target {
	return &NamedFloat64Target{Value: m}
}

type NamedFloat64Target struct {
	Value *NamedFloat64
	vdl.TargetBase
}

func (t *NamedFloat64Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToFloat64(src)
	if err != nil {
		return err
	}
	*t.Value = NamedFloat64(val)

	return nil
}
func (t *NamedFloat64Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToFloat64(src)
	if err != nil {
		return err
	}
	*t.Value = NamedFloat64(val)

	return nil
}
func (t *NamedFloat64Target) FromFloat(src float64, tt *vdl.Type) error {

	*t.Value = NamedFloat64(src)

	return nil
}

func (x *NamedFloat64) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeFloat(64)
	if err != nil {
		return err
	}
	*x = NamedFloat64(tmp)
	return dec.FinishValue()
}

type NamedString string

func (NamedString) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedString"`
}) {
}

func (m *NamedString) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromString(string((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedString) MakeVDLTarget() vdl.Target {
	return &NamedStringTarget{Value: m}
}

type NamedStringTarget struct {
	Value *NamedString
	vdl.TargetBase
}

func (t *NamedStringTarget) FromString(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NamedString)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = NamedString(src)

	return nil
}

func (x *NamedString) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeString()
	if err != nil {
		return err
	}
	*x = NamedString(tmp)
	return dec.FinishValue()
}

type NamedEnum int

const (
	NamedEnumA NamedEnum = iota
	NamedEnumB
	NamedEnumC
)

// NamedEnumAll holds all labels for NamedEnum.
var NamedEnumAll = [...]NamedEnum{NamedEnumA, NamedEnumB, NamedEnumC}

// NamedEnumFromString creates a NamedEnum from a string label.
func NamedEnumFromString(label string) (x NamedEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *NamedEnum) Set(label string) error {
	switch label {
	case "A", "a":
		*x = NamedEnumA
		return nil
	case "B", "b":
		*x = NamedEnumB
		return nil
	case "C", "c":
		*x = NamedEnumC
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in base.NamedEnum", label)
}

// String returns the string label of x.
func (x NamedEnum) String() string {
	switch x {
	case NamedEnumA:
		return "A"
	case NamedEnumB:
		return "B"
	case NamedEnumC:
		return "C"
	}
	return ""
}

func (NamedEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedEnum"`
	Enum struct{ A, B, C string }
}) {
}

func (m *NamedEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *NamedEnum) MakeVDLTarget() vdl.Target {
	return &NamedEnumTarget{Value: m}
}

type NamedEnumTarget struct {
	Value *NamedEnum
	vdl.TargetBase
}

func (t *NamedEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NamedEnum)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "A":
		*t.Value = 0
	case "B":
		*t.Value = 1
	case "C":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum NamedEnum", src)
	}

	return nil
}

func (x *NamedEnum) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err = x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type NamedArray [2]bool

func (NamedArray) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedArray"`
}) {
}

func (m *NamedArray) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 2)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromBool(bool(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NamedArray) MakeVDLTarget() vdl.Target {
	return &NamedArrayTarget{Value: m}
}

// NamedArray
type NamedArrayTarget struct {
	Value      *NamedArray
	elemTarget vdl.BoolTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *NamedArrayTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*NamedArray)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *NamedArrayTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *NamedArrayTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *NamedArrayTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x *NamedArray) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, got %d, want %T", index, *x)
		case done:
			return dec.FinishValue()
		}
		var elem bool
		if err = dec.StartValue(); err != nil {
			return err
		}
		if elem, err = dec.DecodeBool(); err != nil {
			return err
		}
		if err = dec.FinishValue(); err != nil {
			return err
		}
		x[index] = elem
		index++
	}
}

type NamedList []uint32

func (NamedList) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedList"`
}) {
}

func (m *NamedList) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromUint(uint64(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NamedList) MakeVDLTarget() vdl.Target {
	return &NamedListTarget{Value: m}
}

// NamedList
type NamedListTarget struct {
	Value      *NamedList
	elemTarget vdl.Uint32Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *NamedListTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*NamedList)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(NamedList, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *NamedListTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *NamedListTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *NamedListTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x *NamedList) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
	case len > 0:
		*x = make(NamedList, 0, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem uint32
		if err = dec.StartValue(); err != nil {
			return err
		}
		tmp, err := dec.DecodeUint(32)
		if err != nil {
			return err
		}
		elem = uint32(tmp)
		if err = dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type NamedSet map[string]struct{}

func (NamedSet) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedSet"`
}) {
}

func (m *NamedSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NamedSet) MakeVDLTarget() vdl.Target {
	return &NamedSetTarget{Value: m}
}

type NamedSetTarget struct {
	Value     *NamedSet
	currKey   string
	keyTarget vdl.StringTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *NamedSetTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*NamedSet)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(NamedSet)
	return t, nil
}
func (t *NamedSetTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *NamedSetTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *NamedSetTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *NamedSet) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
		return dec.FinishValue()
	case len > 0:
		*x = make(NamedSet, len)
	default:
		*x = make(NamedSet)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var key string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		(*x)[key] = struct{}{}
	}
}

type NamedMap map[string]float32

func (NamedMap) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedMap"`
}) {
}

func (m *NamedMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromFloat(float64(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NamedMap) MakeVDLTarget() vdl.Target {
	return &NamedMapTarget{Value: m}
}

type NamedMapTarget struct {
	Value      *NamedMap
	currKey    string
	currElem   float32
	keyTarget  vdl.StringTarget
	elemTarget vdl.Float32Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *NamedMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*NamedMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(NamedMap)
	return t, nil
}
func (t *NamedMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *NamedMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = float32(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *NamedMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *NamedMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *NamedMap) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
		return dec.FinishValue()
	case len > 0:
		*x = make(NamedMap, len)
	default:
		*x = make(NamedMap)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var key string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem float32
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			elem = float32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		(*x)[key] = elem
	}
}

type NamedStruct struct {
	A bool
	B string
	C int32
}

func (NamedStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedStruct"`
}) {
}

func (m *NamedStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A == false)
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromBool(bool(m.A), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.B == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.B), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.C == int32(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("C"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("C")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromInt(int64(m.C), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NamedStruct) MakeVDLTarget() vdl.Target {
	return &NamedStructTarget{Value: m}
}

type NamedStructTarget struct {
	Value   *NamedStruct
	aTarget vdl.BoolTarget
	bTarget vdl.StringTarget
	cTarget vdl.Int32Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NamedStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*NamedStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *NamedStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "C":
		t.cTarget.Value = &t.Value.C
		target, err := &t.cTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.NamedStruct", name)
	}
}
func (t *NamedStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *NamedStructTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = false
		return nil
	case "B":
		t.Value.B = ""
		return nil
	case "C":
		t.Value.C = int32(0)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.NamedStruct", name)
	}
}
func (t *NamedStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *NamedStruct) VDLRead(dec vdl.Decoder) error {
	*x = NamedStruct{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "A":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "B":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.B, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "C":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.C = int32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type (
	// NamedUnion represents any single field of the NamedUnion union type.
	NamedUnion interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the NamedUnion union type.
		__VDLReflect(__NamedUnionReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// NamedUnionA represents field A of the NamedUnion union type.
	NamedUnionA struct{ Value bool }
	// NamedUnionB represents field B of the NamedUnion union type.
	NamedUnionB struct{ Value string }
	// NamedUnionC represents field C of the NamedUnion union type.
	NamedUnionC struct{ Value int32 }
	// __NamedUnionReflect describes the NamedUnion union type.
	__NamedUnionReflect struct {
		Name               string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedUnion"`
		Type               NamedUnion
		UnionTargetFactory namedUnionTargetFactory
		Union              struct {
			A NamedUnionA
			B NamedUnionB
			C NamedUnionC
		}
	}
)

func (x NamedUnionA) Index() int                       { return 0 }
func (x NamedUnionA) Interface() interface{}           { return x.Value }
func (x NamedUnionA) Name() string                     { return "A" }
func (x NamedUnionA) __VDLReflect(__NamedUnionReflect) {}

func (m NamedUnionA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromBool(bool(m.Value), tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NamedUnionA) MakeVDLTarget() vdl.Target {
	return nil
}

func (x NamedUnionB) Index() int                       { return 1 }
func (x NamedUnionB) Interface() interface{}           { return x.Value }
func (x NamedUnionB) Name() string                     { return "B" }
func (x NamedUnionB) __VDLReflect(__NamedUnionReflect) {}

func (m NamedUnionB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NamedUnionB) MakeVDLTarget() vdl.Target {
	return nil
}

func (x NamedUnionC) Index() int                       { return 2 }
func (x NamedUnionC) Interface() interface{}           { return x.Value }
func (x NamedUnionC) Name() string                     { return "C" }
func (x NamedUnionC) __VDLReflect(__NamedUnionReflect) {}

func (m NamedUnionC) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("C")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromInt(int64(m.Value), tt.NonOptional().Field(2).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NamedUnionC) MakeVDLTarget() vdl.Target {
	return nil
}

type NamedUnionTarget struct {
	Value     *NamedUnion
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NamedUnionTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*NamedUnion)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *NamedUnionTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "A":
		val := false
		return nil, &vdl.BoolTarget{Value: &val}, nil
	case "B":
		val := ""
		return nil, &vdl.StringTarget{Value: &val}, nil
	case "C":
		val := int32(0)
		return nil, &vdl.Int32Target{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/x/ref/lib/vdl/testdata/base.NamedUnion", name)
	}
}
func (t *NamedUnionTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "A":
		*t.Value = NamedUnionA{*(fieldTarget.(*vdl.BoolTarget)).Value}
	case "B":
		*t.Value = NamedUnionB{*(fieldTarget.(*vdl.StringTarget)).Value}
	case "C":
		*t.Value = NamedUnionC{*(fieldTarget.(*vdl.Int32Target)).Value}
	}
	return nil
}
func (t *NamedUnionTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type namedUnionTargetFactory struct{}

func (t namedUnionTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*NamedUnion); ok {
		return &NamedUnionTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *NamedUnion", union)
}

func VDLReadNamedUnion(dec vdl.Decoder, x *NamedUnion) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "A":
		var field NamedUnionA
		if err = dec.StartValue(); err != nil {
			return err
		}
		if field.Value, err = dec.DecodeBool(); err != nil {
			return err
		}
		if err = dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "B":
		var field NamedUnionB
		if err = dec.StartValue(); err != nil {
			return err
		}
		if field.Value, err = dec.DecodeString(); err != nil {
			return err
		}
		if err = dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "C":
		var field NamedUnionC
		if err = dec.StartValue(); err != nil {
			return err
		}
		tmp, err := dec.DecodeInt(32)
		if err != nil {
			return err
		}
		field.Value = int32(tmp)
		if err = dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type Scalars struct {
	A0  bool
	A1  byte
	A2  uint16
	A3  uint32
	A4  uint64
	A5  int8
	A6  int16
	A7  int32
	A8  int64
	A9  float32
	A10 float64
	A11 string
	A12 error
	A13 *vom.RawBytes
	A14 *vdl.Type
	B0  NamedBool
	B1  NamedByte
	B2  NamedUint16
	B3  NamedUint32
	B4  NamedUint64
	B5  NamedInt8
	B6  NamedInt16
	B7  NamedInt32
	B8  NamedInt64
	B9  NamedFloat32
	B10 NamedFloat64
	B11 NamedString
	B12 NamedEnum
	B13 NamedUnion
}

func (Scalars) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.Scalars"`
}) {
}

func (m *Scalars) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A0 == false)
	if var4 {
		if err := fieldsTarget1.ZeroField("A0"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A0")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromBool(bool(m.A0), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.A1 == byte(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("A1"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("A1")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromUint(uint64(m.A1), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.A2 == uint16(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("A2"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("A2")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromUint(uint64(m.A2), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.A3 == uint32(0))
	if var13 {
		if err := fieldsTarget1.ZeroField("A3"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("A3")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromUint(uint64(m.A3), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var16 := (m.A4 == uint64(0))
	if var16 {
		if err := fieldsTarget1.ZeroField("A4"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("A4")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget15.FromUint(uint64(m.A4), tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var19 := (m.A5 == int8(0))
	if var19 {
		if err := fieldsTarget1.ZeroField("A5"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("A5")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget18.FromInt(int64(m.A5), tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
				return err
			}
		}
	}
	var22 := (m.A6 == int16(0))
	if var22 {
		if err := fieldsTarget1.ZeroField("A6"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("A6")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget21.FromInt(int64(m.A6), tt.NonOptional().Field(6).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
				return err
			}
		}
	}
	var25 := (m.A7 == int32(0))
	if var25 {
		if err := fieldsTarget1.ZeroField("A7"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("A7")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget24.FromInt(int64(m.A7), tt.NonOptional().Field(7).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
				return err
			}
		}
	}
	var28 := (m.A8 == int64(0))
	if var28 {
		if err := fieldsTarget1.ZeroField("A8"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("A8")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget27.FromInt(int64(m.A8), tt.NonOptional().Field(8).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
				return err
			}
		}
	}
	var31 := (m.A9 == float32(0))
	if var31 {
		if err := fieldsTarget1.ZeroField("A9"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget29, fieldTarget30, err := fieldsTarget1.StartField("A9")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget30.FromFloat(float64(m.A9), tt.NonOptional().Field(9).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget29, fieldTarget30); err != nil {
				return err
			}
		}
	}
	var34 := (m.A10 == float64(0))
	if var34 {
		if err := fieldsTarget1.ZeroField("A10"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget32, fieldTarget33, err := fieldsTarget1.StartField("A10")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget33.FromFloat(float64(m.A10), tt.NonOptional().Field(10).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget32, fieldTarget33); err != nil {
				return err
			}
		}
	}
	var37 := (m.A11 == "")
	if var37 {
		if err := fieldsTarget1.ZeroField("A11"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget35, fieldTarget36, err := fieldsTarget1.StartField("A11")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget36.FromString(string(m.A11), tt.NonOptional().Field(11).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget35, fieldTarget36); err != nil {
				return err
			}
		}
	}
	var40 := (m.A12 == (error)(nil))
	if var40 {
		if err := fieldsTarget1.ZeroField("A12"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget38, fieldTarget39, err := fieldsTarget1.StartField("A12")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			var wireError41 vdl.WireError
			if err := verror.WireFromNative(&wireError41, m.A12); err != nil {
				return err
			}
			if err := wireError41.FillVDLTarget(fieldTarget39, vdl.ErrorType); err != nil {
				return err
			}

			if err := fieldsTarget1.FinishField(keyTarget38, fieldTarget39); err != nil {
				return err
			}
		}
	}
	var44 := m.A13 == nil || m.A13.IsNilAny()
	if var44 {
		if err := fieldsTarget1.ZeroField("A13"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget42, fieldTarget43, err := fieldsTarget1.StartField("A13")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.A13.FillVDLTarget(fieldTarget43, tt.NonOptional().Field(13).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget42, fieldTarget43); err != nil {
				return err
			}
		}
	}
	var47 := (m.A14 == nil || m.A14 == vdl.AnyType)
	if var47 {
		if err := fieldsTarget1.ZeroField("A14"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget45, fieldTarget46, err := fieldsTarget1.StartField("A14")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			typeObjectVal48 := m.A14
			if typeObjectVal48 == nil {
				typeObjectVal48 = vdl.AnyType
			}
			if err := fieldTarget46.FromTypeObject(typeObjectVal48); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget45, fieldTarget46); err != nil {
				return err
			}
		}
	}
	var51 := (m.B0 == NamedBool(false))
	if var51 {
		if err := fieldsTarget1.ZeroField("B0"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget49, fieldTarget50, err := fieldsTarget1.StartField("B0")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B0.FillVDLTarget(fieldTarget50, tt.NonOptional().Field(15).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget49, fieldTarget50); err != nil {
				return err
			}
		}
	}
	var54 := (m.B1 == NamedByte(0))
	if var54 {
		if err := fieldsTarget1.ZeroField("B1"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget52, fieldTarget53, err := fieldsTarget1.StartField("B1")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B1.FillVDLTarget(fieldTarget53, tt.NonOptional().Field(16).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget52, fieldTarget53); err != nil {
				return err
			}
		}
	}
	var57 := (m.B2 == NamedUint16(0))
	if var57 {
		if err := fieldsTarget1.ZeroField("B2"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget55, fieldTarget56, err := fieldsTarget1.StartField("B2")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B2.FillVDLTarget(fieldTarget56, tt.NonOptional().Field(17).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget55, fieldTarget56); err != nil {
				return err
			}
		}
	}
	var60 := (m.B3 == NamedUint32(0))
	if var60 {
		if err := fieldsTarget1.ZeroField("B3"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget58, fieldTarget59, err := fieldsTarget1.StartField("B3")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B3.FillVDLTarget(fieldTarget59, tt.NonOptional().Field(18).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget58, fieldTarget59); err != nil {
				return err
			}
		}
	}
	var63 := (m.B4 == NamedUint64(0))
	if var63 {
		if err := fieldsTarget1.ZeroField("B4"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget61, fieldTarget62, err := fieldsTarget1.StartField("B4")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B4.FillVDLTarget(fieldTarget62, tt.NonOptional().Field(19).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget61, fieldTarget62); err != nil {
				return err
			}
		}
	}
	var66 := (m.B5 == NamedInt8(0))
	if var66 {
		if err := fieldsTarget1.ZeroField("B5"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget64, fieldTarget65, err := fieldsTarget1.StartField("B5")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B5.FillVDLTarget(fieldTarget65, tt.NonOptional().Field(20).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget64, fieldTarget65); err != nil {
				return err
			}
		}
	}
	var69 := (m.B6 == NamedInt16(0))
	if var69 {
		if err := fieldsTarget1.ZeroField("B6"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget67, fieldTarget68, err := fieldsTarget1.StartField("B6")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B6.FillVDLTarget(fieldTarget68, tt.NonOptional().Field(21).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget67, fieldTarget68); err != nil {
				return err
			}
		}
	}
	var72 := (m.B7 == NamedInt32(0))
	if var72 {
		if err := fieldsTarget1.ZeroField("B7"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget70, fieldTarget71, err := fieldsTarget1.StartField("B7")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B7.FillVDLTarget(fieldTarget71, tt.NonOptional().Field(22).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget70, fieldTarget71); err != nil {
				return err
			}
		}
	}
	var75 := (m.B8 == NamedInt64(0))
	if var75 {
		if err := fieldsTarget1.ZeroField("B8"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget73, fieldTarget74, err := fieldsTarget1.StartField("B8")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B8.FillVDLTarget(fieldTarget74, tt.NonOptional().Field(23).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget73, fieldTarget74); err != nil {
				return err
			}
		}
	}
	var78 := (m.B9 == NamedFloat32(0))
	if var78 {
		if err := fieldsTarget1.ZeroField("B9"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget76, fieldTarget77, err := fieldsTarget1.StartField("B9")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B9.FillVDLTarget(fieldTarget77, tt.NonOptional().Field(24).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget76, fieldTarget77); err != nil {
				return err
			}
		}
	}
	var81 := (m.B10 == NamedFloat64(0))
	if var81 {
		if err := fieldsTarget1.ZeroField("B10"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget79, fieldTarget80, err := fieldsTarget1.StartField("B10")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B10.FillVDLTarget(fieldTarget80, tt.NonOptional().Field(25).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget79, fieldTarget80); err != nil {
				return err
			}
		}
	}
	var84 := (m.B11 == NamedString(""))
	if var84 {
		if err := fieldsTarget1.ZeroField("B11"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget82, fieldTarget83, err := fieldsTarget1.StartField("B11")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B11.FillVDLTarget(fieldTarget83, tt.NonOptional().Field(26).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget82, fieldTarget83); err != nil {
				return err
			}
		}
	}
	var87 := (m.B12 == NamedEnumA)
	if var87 {
		if err := fieldsTarget1.ZeroField("B12"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget85, fieldTarget86, err := fieldsTarget1.StartField("B12")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B12.FillVDLTarget(fieldTarget86, tt.NonOptional().Field(27).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget85, fieldTarget86); err != nil {
				return err
			}
		}
	}
	var var90 bool
	if field, ok := m.B13.(NamedUnionA); ok {

		var91 := (field.Value == false)
		var90 = var91
	}
	if var90 {
		if err := fieldsTarget1.ZeroField("B13"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget88, fieldTarget89, err := fieldsTarget1.StartField("B13")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			unionValue92 := m.B13
			if unionValue92 == nil {
				unionValue92 = NamedUnionA{}
			}
			if err := unionValue92.FillVDLTarget(fieldTarget89, tt.NonOptional().Field(28).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget88, fieldTarget89); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Scalars) MakeVDLTarget() vdl.Target {
	return &ScalarsTarget{Value: m}
}

type ScalarsTarget struct {
	Value     *Scalars
	a0Target  vdl.BoolTarget
	a1Target  vdl.ByteTarget
	a2Target  vdl.Uint16Target
	a3Target  vdl.Uint32Target
	a4Target  vdl.Uint64Target
	a5Target  vdl.Int8Target
	a6Target  vdl.Int16Target
	a7Target  vdl.Int32Target
	a8Target  vdl.Int64Target
	a9Target  vdl.Float32Target
	a10Target vdl.Float64Target
	a11Target vdl.StringTarget
	a12Target verror.ErrorTarget

	a14Target vdl.TypeObjectTarget
	b0Target  NamedBoolTarget
	b1Target  NamedByteTarget
	b2Target  NamedUint16Target
	b3Target  NamedUint32Target
	b4Target  NamedUint64Target
	b5Target  NamedInt8Target
	b6Target  NamedInt16Target
	b7Target  NamedInt32Target
	b8Target  NamedInt64Target
	b9Target  NamedFloat32Target
	b10Target NamedFloat64Target
	b11Target NamedStringTarget
	b12Target NamedEnumTarget
	b13Target NamedUnionTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ScalarsTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Scalars)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ScalarsTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A0":
		t.a0Target.Value = &t.Value.A0
		target, err := &t.a0Target, error(nil)
		return nil, target, err
	case "A1":
		t.a1Target.Value = &t.Value.A1
		target, err := &t.a1Target, error(nil)
		return nil, target, err
	case "A2":
		t.a2Target.Value = &t.Value.A2
		target, err := &t.a2Target, error(nil)
		return nil, target, err
	case "A3":
		t.a3Target.Value = &t.Value.A3
		target, err := &t.a3Target, error(nil)
		return nil, target, err
	case "A4":
		t.a4Target.Value = &t.Value.A4
		target, err := &t.a4Target, error(nil)
		return nil, target, err
	case "A5":
		t.a5Target.Value = &t.Value.A5
		target, err := &t.a5Target, error(nil)
		return nil, target, err
	case "A6":
		t.a6Target.Value = &t.Value.A6
		target, err := &t.a6Target, error(nil)
		return nil, target, err
	case "A7":
		t.a7Target.Value = &t.Value.A7
		target, err := &t.a7Target, error(nil)
		return nil, target, err
	case "A8":
		t.a8Target.Value = &t.Value.A8
		target, err := &t.a8Target, error(nil)
		return nil, target, err
	case "A9":
		t.a9Target.Value = &t.Value.A9
		target, err := &t.a9Target, error(nil)
		return nil, target, err
	case "A10":
		t.a10Target.Value = &t.Value.A10
		target, err := &t.a10Target, error(nil)
		return nil, target, err
	case "A11":
		t.a11Target.Value = &t.Value.A11
		target, err := &t.a11Target, error(nil)
		return nil, target, err
	case "A12":
		t.a12Target.Value = &t.Value.A12
		target, err := &t.a12Target, error(nil)
		return nil, target, err
	case "A13":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.A13))
		return nil, target, err
	case "A14":
		t.a14Target.Value = &t.Value.A14
		target, err := &t.a14Target, error(nil)
		return nil, target, err
	case "B0":
		t.b0Target.Value = &t.Value.B0
		target, err := &t.b0Target, error(nil)
		return nil, target, err
	case "B1":
		t.b1Target.Value = &t.Value.B1
		target, err := &t.b1Target, error(nil)
		return nil, target, err
	case "B2":
		t.b2Target.Value = &t.Value.B2
		target, err := &t.b2Target, error(nil)
		return nil, target, err
	case "B3":
		t.b3Target.Value = &t.Value.B3
		target, err := &t.b3Target, error(nil)
		return nil, target, err
	case "B4":
		t.b4Target.Value = &t.Value.B4
		target, err := &t.b4Target, error(nil)
		return nil, target, err
	case "B5":
		t.b5Target.Value = &t.Value.B5
		target, err := &t.b5Target, error(nil)
		return nil, target, err
	case "B6":
		t.b6Target.Value = &t.Value.B6
		target, err := &t.b6Target, error(nil)
		return nil, target, err
	case "B7":
		t.b7Target.Value = &t.Value.B7
		target, err := &t.b7Target, error(nil)
		return nil, target, err
	case "B8":
		t.b8Target.Value = &t.Value.B8
		target, err := &t.b8Target, error(nil)
		return nil, target, err
	case "B9":
		t.b9Target.Value = &t.Value.B9
		target, err := &t.b9Target, error(nil)
		return nil, target, err
	case "B10":
		t.b10Target.Value = &t.Value.B10
		target, err := &t.b10Target, error(nil)
		return nil, target, err
	case "B11":
		t.b11Target.Value = &t.Value.B11
		target, err := &t.b11Target, error(nil)
		return nil, target, err
	case "B12":
		t.b12Target.Value = &t.Value.B12
		target, err := &t.b12Target, error(nil)
		return nil, target, err
	case "B13":
		t.b13Target.Value = &t.Value.B13
		target, err := &t.b13Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.Scalars", name)
	}
}
func (t *ScalarsTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ScalarsTarget) ZeroField(name string) error {
	switch name {
	case "A0":
		t.Value.A0 = false
		return nil
	case "A1":
		t.Value.A1 = byte(0)
		return nil
	case "A2":
		t.Value.A2 = uint16(0)
		return nil
	case "A3":
		t.Value.A3 = uint32(0)
		return nil
	case "A4":
		t.Value.A4 = uint64(0)
		return nil
	case "A5":
		t.Value.A5 = int8(0)
		return nil
	case "A6":
		t.Value.A6 = int16(0)
		return nil
	case "A7":
		t.Value.A7 = int32(0)
		return nil
	case "A8":
		t.Value.A8 = int64(0)
		return nil
	case "A9":
		t.Value.A9 = float32(0)
		return nil
	case "A10":
		t.Value.A10 = float64(0)
		return nil
	case "A11":
		t.Value.A11 = ""
		return nil
	case "A12":
		t.Value.A12 = (error)(nil)
		return nil
	case "A13":
		t.Value.A13 = vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType))
		return nil
	case "A14":
		t.Value.A14 = vdl.AnyType
		return nil
	case "B0":
		t.Value.B0 = NamedBool(false)
		return nil
	case "B1":
		t.Value.B1 = NamedByte(0)
		return nil
	case "B2":
		t.Value.B2 = NamedUint16(0)
		return nil
	case "B3":
		t.Value.B3 = NamedUint32(0)
		return nil
	case "B4":
		t.Value.B4 = NamedUint64(0)
		return nil
	case "B5":
		t.Value.B5 = NamedInt8(0)
		return nil
	case "B6":
		t.Value.B6 = NamedInt16(0)
		return nil
	case "B7":
		t.Value.B7 = NamedInt32(0)
		return nil
	case "B8":
		t.Value.B8 = NamedInt64(0)
		return nil
	case "B9":
		t.Value.B9 = NamedFloat32(0)
		return nil
	case "B10":
		t.Value.B10 = NamedFloat64(0)
		return nil
	case "B11":
		t.Value.B11 = NamedString("")
		return nil
	case "B12":
		t.Value.B12 = NamedEnumA
		return nil
	case "B13":
		t.Value.B13 = NamedUnion(NamedUnionA{})
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.Scalars", name)
	}
}
func (t *ScalarsTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *Scalars) VDLRead(dec vdl.Decoder) error {
	*x = Scalars{
		A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
		A14: vdl.AnyType,
		B13: NamedUnionA{},
	}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "A0":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A0, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A1":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.A1 = byte(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A2":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			x.A2 = uint16(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A3":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			x.A3 = uint32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A4":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A4, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A5":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(8)
			if err != nil {
				return err
			}
			x.A5 = int8(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A6":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			x.A6 = int16(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A7":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.A7 = int32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A8":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A8, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A9":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			x.A9 = float32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A10":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A10, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A11":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A11, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A12":
			match++
			if err = verror.VDLRead(dec, &x.A12); err != nil {
				return err
			}
		case "A13":
			match++
			// TODO(toddw): implement any
		case "A14":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A14, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "B0":
			match++
			if err = x.B0.VDLRead(dec); err != nil {
				return err
			}
		case "B1":
			match++
			if err = x.B1.VDLRead(dec); err != nil {
				return err
			}
		case "B2":
			match++
			if err = x.B2.VDLRead(dec); err != nil {
				return err
			}
		case "B3":
			match++
			if err = x.B3.VDLRead(dec); err != nil {
				return err
			}
		case "B4":
			match++
			if err = x.B4.VDLRead(dec); err != nil {
				return err
			}
		case "B5":
			match++
			if err = x.B5.VDLRead(dec); err != nil {
				return err
			}
		case "B6":
			match++
			if err = x.B6.VDLRead(dec); err != nil {
				return err
			}
		case "B7":
			match++
			if err = x.B7.VDLRead(dec); err != nil {
				return err
			}
		case "B8":
			match++
			if err = x.B8.VDLRead(dec); err != nil {
				return err
			}
		case "B9":
			match++
			if err = x.B9.VDLRead(dec); err != nil {
				return err
			}
		case "B10":
			match++
			if err = x.B10.VDLRead(dec); err != nil {
				return err
			}
		case "B11":
			match++
			if err = x.B11.VDLRead(dec); err != nil {
				return err
			}
		case "B12":
			match++
			if err = x.B12.VDLRead(dec); err != nil {
				return err
			}
		case "B13":
			match++
			if err = VDLReadNamedUnion(dec, &x.B13); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// These are all scalars that may be used as map or set keys.
type KeyScalars struct {
	A0  bool
	A1  byte
	A2  uint16
	A3  uint32
	A4  uint64
	A5  int8
	A6  int16
	A7  int32
	A8  int64
	A9  float32
	A10 float64
	A11 string
	B0  NamedBool
	B1  NamedByte
	B2  NamedUint16
	B3  NamedUint32
	B4  NamedUint64
	B5  NamedInt8
	B6  NamedInt16
	B7  NamedInt32
	B8  NamedInt64
	B9  NamedFloat32
	B10 NamedFloat64
	B13 NamedString
}

func (KeyScalars) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.KeyScalars"`
}) {
}

func (m *KeyScalars) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A0 == false)
	if var4 {
		if err := fieldsTarget1.ZeroField("A0"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A0")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromBool(bool(m.A0), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.A1 == byte(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("A1"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("A1")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromUint(uint64(m.A1), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.A2 == uint16(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("A2"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("A2")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromUint(uint64(m.A2), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.A3 == uint32(0))
	if var13 {
		if err := fieldsTarget1.ZeroField("A3"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("A3")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromUint(uint64(m.A3), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var16 := (m.A4 == uint64(0))
	if var16 {
		if err := fieldsTarget1.ZeroField("A4"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("A4")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget15.FromUint(uint64(m.A4), tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var19 := (m.A5 == int8(0))
	if var19 {
		if err := fieldsTarget1.ZeroField("A5"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("A5")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget18.FromInt(int64(m.A5), tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
				return err
			}
		}
	}
	var22 := (m.A6 == int16(0))
	if var22 {
		if err := fieldsTarget1.ZeroField("A6"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("A6")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget21.FromInt(int64(m.A6), tt.NonOptional().Field(6).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
				return err
			}
		}
	}
	var25 := (m.A7 == int32(0))
	if var25 {
		if err := fieldsTarget1.ZeroField("A7"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("A7")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget24.FromInt(int64(m.A7), tt.NonOptional().Field(7).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
				return err
			}
		}
	}
	var28 := (m.A8 == int64(0))
	if var28 {
		if err := fieldsTarget1.ZeroField("A8"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("A8")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget27.FromInt(int64(m.A8), tt.NonOptional().Field(8).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
				return err
			}
		}
	}
	var31 := (m.A9 == float32(0))
	if var31 {
		if err := fieldsTarget1.ZeroField("A9"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget29, fieldTarget30, err := fieldsTarget1.StartField("A9")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget30.FromFloat(float64(m.A9), tt.NonOptional().Field(9).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget29, fieldTarget30); err != nil {
				return err
			}
		}
	}
	var34 := (m.A10 == float64(0))
	if var34 {
		if err := fieldsTarget1.ZeroField("A10"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget32, fieldTarget33, err := fieldsTarget1.StartField("A10")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget33.FromFloat(float64(m.A10), tt.NonOptional().Field(10).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget32, fieldTarget33); err != nil {
				return err
			}
		}
	}
	var37 := (m.A11 == "")
	if var37 {
		if err := fieldsTarget1.ZeroField("A11"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget35, fieldTarget36, err := fieldsTarget1.StartField("A11")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget36.FromString(string(m.A11), tt.NonOptional().Field(11).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget35, fieldTarget36); err != nil {
				return err
			}
		}
	}
	var40 := (m.B0 == NamedBool(false))
	if var40 {
		if err := fieldsTarget1.ZeroField("B0"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget38, fieldTarget39, err := fieldsTarget1.StartField("B0")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B0.FillVDLTarget(fieldTarget39, tt.NonOptional().Field(12).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget38, fieldTarget39); err != nil {
				return err
			}
		}
	}
	var43 := (m.B1 == NamedByte(0))
	if var43 {
		if err := fieldsTarget1.ZeroField("B1"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget41, fieldTarget42, err := fieldsTarget1.StartField("B1")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B1.FillVDLTarget(fieldTarget42, tt.NonOptional().Field(13).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget41, fieldTarget42); err != nil {
				return err
			}
		}
	}
	var46 := (m.B2 == NamedUint16(0))
	if var46 {
		if err := fieldsTarget1.ZeroField("B2"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget44, fieldTarget45, err := fieldsTarget1.StartField("B2")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B2.FillVDLTarget(fieldTarget45, tt.NonOptional().Field(14).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget44, fieldTarget45); err != nil {
				return err
			}
		}
	}
	var49 := (m.B3 == NamedUint32(0))
	if var49 {
		if err := fieldsTarget1.ZeroField("B3"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget47, fieldTarget48, err := fieldsTarget1.StartField("B3")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B3.FillVDLTarget(fieldTarget48, tt.NonOptional().Field(15).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget47, fieldTarget48); err != nil {
				return err
			}
		}
	}
	var52 := (m.B4 == NamedUint64(0))
	if var52 {
		if err := fieldsTarget1.ZeroField("B4"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget50, fieldTarget51, err := fieldsTarget1.StartField("B4")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B4.FillVDLTarget(fieldTarget51, tt.NonOptional().Field(16).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget50, fieldTarget51); err != nil {
				return err
			}
		}
	}
	var55 := (m.B5 == NamedInt8(0))
	if var55 {
		if err := fieldsTarget1.ZeroField("B5"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget53, fieldTarget54, err := fieldsTarget1.StartField("B5")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B5.FillVDLTarget(fieldTarget54, tt.NonOptional().Field(17).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget53, fieldTarget54); err != nil {
				return err
			}
		}
	}
	var58 := (m.B6 == NamedInt16(0))
	if var58 {
		if err := fieldsTarget1.ZeroField("B6"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget56, fieldTarget57, err := fieldsTarget1.StartField("B6")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B6.FillVDLTarget(fieldTarget57, tt.NonOptional().Field(18).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget56, fieldTarget57); err != nil {
				return err
			}
		}
	}
	var61 := (m.B7 == NamedInt32(0))
	if var61 {
		if err := fieldsTarget1.ZeroField("B7"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget59, fieldTarget60, err := fieldsTarget1.StartField("B7")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B7.FillVDLTarget(fieldTarget60, tt.NonOptional().Field(19).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget59, fieldTarget60); err != nil {
				return err
			}
		}
	}
	var64 := (m.B8 == NamedInt64(0))
	if var64 {
		if err := fieldsTarget1.ZeroField("B8"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget62, fieldTarget63, err := fieldsTarget1.StartField("B8")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B8.FillVDLTarget(fieldTarget63, tt.NonOptional().Field(20).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget62, fieldTarget63); err != nil {
				return err
			}
		}
	}
	var67 := (m.B9 == NamedFloat32(0))
	if var67 {
		if err := fieldsTarget1.ZeroField("B9"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget65, fieldTarget66, err := fieldsTarget1.StartField("B9")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B9.FillVDLTarget(fieldTarget66, tt.NonOptional().Field(21).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget65, fieldTarget66); err != nil {
				return err
			}
		}
	}
	var70 := (m.B10 == NamedFloat64(0))
	if var70 {
		if err := fieldsTarget1.ZeroField("B10"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget68, fieldTarget69, err := fieldsTarget1.StartField("B10")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B10.FillVDLTarget(fieldTarget69, tt.NonOptional().Field(22).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget68, fieldTarget69); err != nil {
				return err
			}
		}
	}
	var73 := (m.B13 == NamedString(""))
	if var73 {
		if err := fieldsTarget1.ZeroField("B13"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget71, fieldTarget72, err := fieldsTarget1.StartField("B13")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B13.FillVDLTarget(fieldTarget72, tt.NonOptional().Field(23).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget71, fieldTarget72); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *KeyScalars) MakeVDLTarget() vdl.Target {
	return &KeyScalarsTarget{Value: m}
}

type KeyScalarsTarget struct {
	Value     *KeyScalars
	a0Target  vdl.BoolTarget
	a1Target  vdl.ByteTarget
	a2Target  vdl.Uint16Target
	a3Target  vdl.Uint32Target
	a4Target  vdl.Uint64Target
	a5Target  vdl.Int8Target
	a6Target  vdl.Int16Target
	a7Target  vdl.Int32Target
	a8Target  vdl.Int64Target
	a9Target  vdl.Float32Target
	a10Target vdl.Float64Target
	a11Target vdl.StringTarget
	b0Target  NamedBoolTarget
	b1Target  NamedByteTarget
	b2Target  NamedUint16Target
	b3Target  NamedUint32Target
	b4Target  NamedUint64Target
	b5Target  NamedInt8Target
	b6Target  NamedInt16Target
	b7Target  NamedInt32Target
	b8Target  NamedInt64Target
	b9Target  NamedFloat32Target
	b10Target NamedFloat64Target
	b13Target NamedStringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *KeyScalarsTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*KeyScalars)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *KeyScalarsTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A0":
		t.a0Target.Value = &t.Value.A0
		target, err := &t.a0Target, error(nil)
		return nil, target, err
	case "A1":
		t.a1Target.Value = &t.Value.A1
		target, err := &t.a1Target, error(nil)
		return nil, target, err
	case "A2":
		t.a2Target.Value = &t.Value.A2
		target, err := &t.a2Target, error(nil)
		return nil, target, err
	case "A3":
		t.a3Target.Value = &t.Value.A3
		target, err := &t.a3Target, error(nil)
		return nil, target, err
	case "A4":
		t.a4Target.Value = &t.Value.A4
		target, err := &t.a4Target, error(nil)
		return nil, target, err
	case "A5":
		t.a5Target.Value = &t.Value.A5
		target, err := &t.a5Target, error(nil)
		return nil, target, err
	case "A6":
		t.a6Target.Value = &t.Value.A6
		target, err := &t.a6Target, error(nil)
		return nil, target, err
	case "A7":
		t.a7Target.Value = &t.Value.A7
		target, err := &t.a7Target, error(nil)
		return nil, target, err
	case "A8":
		t.a8Target.Value = &t.Value.A8
		target, err := &t.a8Target, error(nil)
		return nil, target, err
	case "A9":
		t.a9Target.Value = &t.Value.A9
		target, err := &t.a9Target, error(nil)
		return nil, target, err
	case "A10":
		t.a10Target.Value = &t.Value.A10
		target, err := &t.a10Target, error(nil)
		return nil, target, err
	case "A11":
		t.a11Target.Value = &t.Value.A11
		target, err := &t.a11Target, error(nil)
		return nil, target, err
	case "B0":
		t.b0Target.Value = &t.Value.B0
		target, err := &t.b0Target, error(nil)
		return nil, target, err
	case "B1":
		t.b1Target.Value = &t.Value.B1
		target, err := &t.b1Target, error(nil)
		return nil, target, err
	case "B2":
		t.b2Target.Value = &t.Value.B2
		target, err := &t.b2Target, error(nil)
		return nil, target, err
	case "B3":
		t.b3Target.Value = &t.Value.B3
		target, err := &t.b3Target, error(nil)
		return nil, target, err
	case "B4":
		t.b4Target.Value = &t.Value.B4
		target, err := &t.b4Target, error(nil)
		return nil, target, err
	case "B5":
		t.b5Target.Value = &t.Value.B5
		target, err := &t.b5Target, error(nil)
		return nil, target, err
	case "B6":
		t.b6Target.Value = &t.Value.B6
		target, err := &t.b6Target, error(nil)
		return nil, target, err
	case "B7":
		t.b7Target.Value = &t.Value.B7
		target, err := &t.b7Target, error(nil)
		return nil, target, err
	case "B8":
		t.b8Target.Value = &t.Value.B8
		target, err := &t.b8Target, error(nil)
		return nil, target, err
	case "B9":
		t.b9Target.Value = &t.Value.B9
		target, err := &t.b9Target, error(nil)
		return nil, target, err
	case "B10":
		t.b10Target.Value = &t.Value.B10
		target, err := &t.b10Target, error(nil)
		return nil, target, err
	case "B13":
		t.b13Target.Value = &t.Value.B13
		target, err := &t.b13Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.KeyScalars", name)
	}
}
func (t *KeyScalarsTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *KeyScalarsTarget) ZeroField(name string) error {
	switch name {
	case "A0":
		t.Value.A0 = false
		return nil
	case "A1":
		t.Value.A1 = byte(0)
		return nil
	case "A2":
		t.Value.A2 = uint16(0)
		return nil
	case "A3":
		t.Value.A3 = uint32(0)
		return nil
	case "A4":
		t.Value.A4 = uint64(0)
		return nil
	case "A5":
		t.Value.A5 = int8(0)
		return nil
	case "A6":
		t.Value.A6 = int16(0)
		return nil
	case "A7":
		t.Value.A7 = int32(0)
		return nil
	case "A8":
		t.Value.A8 = int64(0)
		return nil
	case "A9":
		t.Value.A9 = float32(0)
		return nil
	case "A10":
		t.Value.A10 = float64(0)
		return nil
	case "A11":
		t.Value.A11 = ""
		return nil
	case "B0":
		t.Value.B0 = NamedBool(false)
		return nil
	case "B1":
		t.Value.B1 = NamedByte(0)
		return nil
	case "B2":
		t.Value.B2 = NamedUint16(0)
		return nil
	case "B3":
		t.Value.B3 = NamedUint32(0)
		return nil
	case "B4":
		t.Value.B4 = NamedUint64(0)
		return nil
	case "B5":
		t.Value.B5 = NamedInt8(0)
		return nil
	case "B6":
		t.Value.B6 = NamedInt16(0)
		return nil
	case "B7":
		t.Value.B7 = NamedInt32(0)
		return nil
	case "B8":
		t.Value.B8 = NamedInt64(0)
		return nil
	case "B9":
		t.Value.B9 = NamedFloat32(0)
		return nil
	case "B10":
		t.Value.B10 = NamedFloat64(0)
		return nil
	case "B13":
		t.Value.B13 = NamedString("")
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.KeyScalars", name)
	}
}
func (t *KeyScalarsTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *KeyScalars) VDLRead(dec vdl.Decoder) error {
	*x = KeyScalars{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "A0":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A0, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A1":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.A1 = byte(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A2":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			x.A2 = uint16(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A3":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			x.A3 = uint32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A4":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A4, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A5":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(8)
			if err != nil {
				return err
			}
			x.A5 = int8(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A6":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			x.A6 = int16(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A7":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.A7 = int32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A8":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A8, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A9":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			x.A9 = float32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A10":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A10, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "A11":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.A11, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "B0":
			match++
			if err = x.B0.VDLRead(dec); err != nil {
				return err
			}
		case "B1":
			match++
			if err = x.B1.VDLRead(dec); err != nil {
				return err
			}
		case "B2":
			match++
			if err = x.B2.VDLRead(dec); err != nil {
				return err
			}
		case "B3":
			match++
			if err = x.B3.VDLRead(dec); err != nil {
				return err
			}
		case "B4":
			match++
			if err = x.B4.VDLRead(dec); err != nil {
				return err
			}
		case "B5":
			match++
			if err = x.B5.VDLRead(dec); err != nil {
				return err
			}
		case "B6":
			match++
			if err = x.B6.VDLRead(dec); err != nil {
				return err
			}
		case "B7":
			match++
			if err = x.B7.VDLRead(dec); err != nil {
				return err
			}
		case "B8":
			match++
			if err = x.B8.VDLRead(dec); err != nil {
				return err
			}
		case "B9":
			match++
			if err = x.B9.VDLRead(dec); err != nil {
				return err
			}
		case "B10":
			match++
			if err = x.B10.VDLRead(dec); err != nil {
				return err
			}
		case "B13":
			match++
			if err = x.B13.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type ScalarsArray [2]Scalars

func (ScalarsArray) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.ScalarsArray"`
}) {
}

func (m *ScalarsArray) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 2)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ScalarsArray) MakeVDLTarget() vdl.Target {
	return &ScalarsArrayTarget{Value: m}
}

// ScalarsArray
type ScalarsArrayTarget struct {
	Value      *ScalarsArray
	elemTarget ScalarsTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *ScalarsArrayTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*ScalarsArray)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ScalarsArrayTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *ScalarsArrayTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *ScalarsArrayTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x *ScalarsArray) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, got %d, want %T", index, *x)
		case done:
			return dec.FinishValue()
		}
		var elem Scalars
		if err = elem.VDLRead(dec); err != nil {
			return err
		}
		x[index] = elem
		index++
	}
}

type Composites struct {
	A0 Scalars
	A1 ScalarsArray
	A2 []Scalars
	A3 map[KeyScalars]struct{}
	A4 map[string]Scalars
}

func (Composites) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.Composites"`
}) {
}

func (m *Composites) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := true
	var5 := (m.A0.A0 == false)
	var4 = var4 && var5
	var6 := (m.A0.A1 == byte(0))
	var4 = var4 && var6
	var7 := (m.A0.A2 == uint16(0))
	var4 = var4 && var7
	var8 := (m.A0.A3 == uint32(0))
	var4 = var4 && var8
	var9 := (m.A0.A4 == uint64(0))
	var4 = var4 && var9
	var10 := (m.A0.A5 == int8(0))
	var4 = var4 && var10
	var11 := (m.A0.A6 == int16(0))
	var4 = var4 && var11
	var12 := (m.A0.A7 == int32(0))
	var4 = var4 && var12
	var13 := (m.A0.A8 == int64(0))
	var4 = var4 && var13
	var14 := (m.A0.A9 == float32(0))
	var4 = var4 && var14
	var15 := (m.A0.A10 == float64(0))
	var4 = var4 && var15
	var16 := (m.A0.A11 == "")
	var4 = var4 && var16
	var17 := (m.A0.A12 == (error)(nil))
	var4 = var4 && var17
	var18 := m.A0.A13 == nil || m.A0.A13.IsNilAny()
	var4 = var4 && var18
	var19 := (m.A0.A14 == nil || m.A0.A14 == vdl.AnyType)
	var4 = var4 && var19
	var20 := (m.A0.B0 == NamedBool(false))
	var4 = var4 && var20
	var21 := (m.A0.B1 == NamedByte(0))
	var4 = var4 && var21
	var22 := (m.A0.B2 == NamedUint16(0))
	var4 = var4 && var22
	var23 := (m.A0.B3 == NamedUint32(0))
	var4 = var4 && var23
	var24 := (m.A0.B4 == NamedUint64(0))
	var4 = var4 && var24
	var25 := (m.A0.B5 == NamedInt8(0))
	var4 = var4 && var25
	var26 := (m.A0.B6 == NamedInt16(0))
	var4 = var4 && var26
	var27 := (m.A0.B7 == NamedInt32(0))
	var4 = var4 && var27
	var28 := (m.A0.B8 == NamedInt64(0))
	var4 = var4 && var28
	var29 := (m.A0.B9 == NamedFloat32(0))
	var4 = var4 && var29
	var30 := (m.A0.B10 == NamedFloat64(0))
	var4 = var4 && var30
	var31 := (m.A0.B11 == NamedString(""))
	var4 = var4 && var31
	var32 := (m.A0.B12 == NamedEnumA)
	var4 = var4 && var32
	var var33 bool
	if field, ok := m.A0.B13.(NamedUnionA); ok {

		var34 := (field.Value == false)
		var33 = var34
	}
	var4 = var4 && var33
	if var4 {
		if err := fieldsTarget1.ZeroField("A0"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A0")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.A0.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var37 := true
	for _, elem38 := range m.A1 {

		var39 := true
		var40 := (elem38.A0 == false)
		var39 = var39 && var40
		var41 := (elem38.A1 == byte(0))
		var39 = var39 && var41
		var42 := (elem38.A2 == uint16(0))
		var39 = var39 && var42
		var43 := (elem38.A3 == uint32(0))
		var39 = var39 && var43
		var44 := (elem38.A4 == uint64(0))
		var39 = var39 && var44
		var45 := (elem38.A5 == int8(0))
		var39 = var39 && var45
		var46 := (elem38.A6 == int16(0))
		var39 = var39 && var46
		var47 := (elem38.A7 == int32(0))
		var39 = var39 && var47
		var48 := (elem38.A8 == int64(0))
		var39 = var39 && var48
		var49 := (elem38.A9 == float32(0))
		var39 = var39 && var49
		var50 := (elem38.A10 == float64(0))
		var39 = var39 && var50
		var51 := (elem38.A11 == "")
		var39 = var39 && var51
		var52 := (elem38.A12 == (error)(nil))
		var39 = var39 && var52
		var53 := elem38.A13 == nil || elem38.A13.IsNilAny()
		var39 = var39 && var53
		var54 := (elem38.A14 == nil || elem38.A14 == vdl.AnyType)
		var39 = var39 && var54
		var55 := (elem38.B0 == NamedBool(false))
		var39 = var39 && var55
		var56 := (elem38.B1 == NamedByte(0))
		var39 = var39 && var56
		var57 := (elem38.B2 == NamedUint16(0))
		var39 = var39 && var57
		var58 := (elem38.B3 == NamedUint32(0))
		var39 = var39 && var58
		var59 := (elem38.B4 == NamedUint64(0))
		var39 = var39 && var59
		var60 := (elem38.B5 == NamedInt8(0))
		var39 = var39 && var60
		var61 := (elem38.B6 == NamedInt16(0))
		var39 = var39 && var61
		var62 := (elem38.B7 == NamedInt32(0))
		var39 = var39 && var62
		var63 := (elem38.B8 == NamedInt64(0))
		var39 = var39 && var63
		var64 := (elem38.B9 == NamedFloat32(0))
		var39 = var39 && var64
		var65 := (elem38.B10 == NamedFloat64(0))
		var39 = var39 && var65
		var66 := (elem38.B11 == NamedString(""))
		var39 = var39 && var66
		var67 := (elem38.B12 == NamedEnumA)
		var39 = var39 && var67
		var var68 bool
		if field, ok := elem38.B13.(NamedUnionA); ok {

			var69 := (field.Value == false)
			var68 = var69
		}
		var39 = var39 && var68
		if !var39 {
			var37 = false
			break
		}
	}
	if var37 {
		if err := fieldsTarget1.ZeroField("A1"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget35, fieldTarget36, err := fieldsTarget1.StartField("A1")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.A1.FillVDLTarget(fieldTarget36, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget35, fieldTarget36); err != nil {
				return err
			}
		}
	}
	var var72 bool
	if len(m.A2) == 0 {
		var72 = true
	}
	if var72 {
		if err := fieldsTarget1.ZeroField("A2"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget70, fieldTarget71, err := fieldsTarget1.StartField("A2")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget73, err := fieldTarget71.StartList(tt.NonOptional().Field(2).Type, len(m.A2))
			if err != nil {
				return err
			}
			for i, elem75 := range m.A2 {
				elemTarget74, err := listTarget73.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem75.FillVDLTarget(elemTarget74, tt.NonOptional().Field(2).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget73.FinishElem(elemTarget74); err != nil {
					return err
				}
			}
			if err := fieldTarget71.FinishList(listTarget73); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget70, fieldTarget71); err != nil {
				return err
			}
		}
	}
	var var78 bool
	if len(m.A3) == 0 {
		var78 = true
	}
	if var78 {
		if err := fieldsTarget1.ZeroField("A3"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget76, fieldTarget77, err := fieldsTarget1.StartField("A3")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget79, err := fieldTarget77.StartSet(tt.NonOptional().Field(3).Type, len(m.A3))
			if err != nil {
				return err
			}
			for key81 := range m.A3 {
				keyTarget80, err := setTarget79.StartKey()
				if err != nil {
					return err
				}

				if err := key81.FillVDLTarget(keyTarget80, tt.NonOptional().Field(3).Type.Key()); err != nil {
					return err
				}
				if err := setTarget79.FinishKey(keyTarget80); err != nil {
					return err
				}
			}
			if err := fieldTarget77.FinishSet(setTarget79); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget76, fieldTarget77); err != nil {
				return err
			}
		}
	}
	var var84 bool
	if len(m.A4) == 0 {
		var84 = true
	}
	if var84 {
		if err := fieldsTarget1.ZeroField("A4"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget82, fieldTarget83, err := fieldsTarget1.StartField("A4")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget85, err := fieldTarget83.StartMap(tt.NonOptional().Field(4).Type, len(m.A4))
			if err != nil {
				return err
			}
			for key87, value89 := range m.A4 {
				keyTarget86, err := mapTarget85.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget86.FromString(string(key87), tt.NonOptional().Field(4).Type.Key()); err != nil {
					return err
				}
				valueTarget88, err := mapTarget85.FinishKeyStartField(keyTarget86)
				if err != nil {
					return err
				}

				if err := value89.FillVDLTarget(valueTarget88, tt.NonOptional().Field(4).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget85.FinishField(keyTarget86, valueTarget88); err != nil {
					return err
				}
			}
			if err := fieldTarget83.FinishMap(mapTarget85); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget82, fieldTarget83); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Composites) MakeVDLTarget() vdl.Target {
	return &CompositesTarget{Value: m}
}

type CompositesTarget struct {
	Value    *Composites
	a0Target ScalarsTarget
	a1Target ScalarsArrayTarget
	a2Target __VDLTarget1_list
	a3Target __VDLTarget2_set
	a4Target __VDLTarget3_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CompositesTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Composites)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CompositesTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A0":
		t.a0Target.Value = &t.Value.A0
		target, err := &t.a0Target, error(nil)
		return nil, target, err
	case "A1":
		t.a1Target.Value = &t.Value.A1
		target, err := &t.a1Target, error(nil)
		return nil, target, err
	case "A2":
		t.a2Target.Value = &t.Value.A2
		target, err := &t.a2Target, error(nil)
		return nil, target, err
	case "A3":
		t.a3Target.Value = &t.Value.A3
		target, err := &t.a3Target, error(nil)
		return nil, target, err
	case "A4":
		t.a4Target.Value = &t.Value.A4
		target, err := &t.a4Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.Composites", name)
	}
}
func (t *CompositesTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CompositesTarget) ZeroField(name string) error {
	switch name {
	case "A0":
		t.Value.A0 = Scalars{
			A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
			A14: vdl.AnyType,
			B13: NamedUnionA{},
		}
		return nil
	case "A1":
		t.Value.A1 = ScalarsArray{
			{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
			{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
		}
		return nil
	case "A2":
		t.Value.A2 = []Scalars(nil)
		return nil
	case "A3":
		t.Value.A3 = map[KeyScalars]struct{}(nil)
		return nil
	case "A4":
		t.Value.A4 = map[string]Scalars(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.Composites", name)
	}
}
func (t *CompositesTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []Scalars
type __VDLTarget1_list struct {
	Value      *[]Scalars
	elemTarget ScalarsTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Scalars)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Scalars, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// map[KeyScalars]struct{}
type __VDLTarget2_set struct {
	Value     *map[KeyScalars]struct{}
	currKey   KeyScalars
	keyTarget KeyScalarsTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget2_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[KeyScalars]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[KeyScalars]struct{})
	return t, nil
}
func (t *__VDLTarget2_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = KeyScalars{}
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget2_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[string]Scalars
type __VDLTarget3_map struct {
	Value      *map[string]Scalars
	currKey    string
	currElem   Scalars
	keyTarget  vdl.StringTarget
	elemTarget ScalarsTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget3_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]Scalars)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]Scalars)
	return t, nil
}
func (t *__VDLTarget3_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = Scalars{
		A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
		A14: vdl.AnyType,
		B13: NamedUnionA{},
	}
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget3_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *Composites) VDLRead(dec vdl.Decoder) error {
	*x = Composites{
		A0: Scalars{
			A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
			A14: vdl.AnyType,
			B13: NamedUnionA{},
		},
		A1: ScalarsArray{
			{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
			{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
		},
	}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "A0":
			match++
			if err = x.A0.VDLRead(dec); err != nil {
				return err
			}
		case "A1":
			match++
			if err = x.A1.VDLRead(dec); err != nil {
				return err
			}
		case "A2":
			match++
			if err = __VDLRead1_list(dec, &x.A2); err != nil {
				return err
			}
		case "A3":
			match++
			if err = __VDLRead2_set(dec, &x.A3); err != nil {
				return err
			}
		case "A4":
			match++
			if err = __VDLRead3_map(dec, &x.A4); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead1_list(dec vdl.Decoder, x *[]Scalars) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
	case len > 0:
		*x = make([]Scalars, 0, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Scalars
		if err = elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLRead2_set(dec vdl.Decoder, x *map[KeyScalars]struct{}) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
		return dec.FinishValue()
	case len > 0:
		*x = make(map[KeyScalars]struct{}, len)
	default:
		*x = make(map[KeyScalars]struct{})
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var key KeyScalars
		{
			if err = key.VDLRead(dec); err != nil {
				return err
			}
		}
		(*x)[key] = struct{}{}
	}
}

func __VDLRead3_map(dec vdl.Decoder, x *map[string]Scalars) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
		return dec.FinishValue()
	case len > 0:
		*x = make(map[string]Scalars, len)
	default:
		*x = make(map[string]Scalars)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var key string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem Scalars
		{
			if err = elem.VDLRead(dec); err != nil {
				return err
			}
		}
		(*x)[key] = elem
	}
}

type CompositesArray [2]Composites

func (CompositesArray) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.CompositesArray"`
}) {
}

func (m *CompositesArray) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 2)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *CompositesArray) MakeVDLTarget() vdl.Target {
	return &CompositesArrayTarget{Value: m}
}

// CompositesArray
type CompositesArrayTarget struct {
	Value      *CompositesArray
	elemTarget CompositesTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *CompositesArrayTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*CompositesArray)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CompositesArrayTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *CompositesArrayTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *CompositesArrayTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x *CompositesArray) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, got %d, want %T", index, *x)
		case done:
			return dec.FinishValue()
		}
		var elem Composites
		if err = elem.VDLRead(dec); err != nil {
			return err
		}
		x[index] = elem
		index++
	}
}

type CompComp struct {
	A0 Composites
	A1 CompositesArray
	A2 []Composites
	A3 map[string]Composites
	A4 map[KeyScalars][]map[string]Composites
}

func (CompComp) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.CompComp"`
}) {
}

func (m *CompComp) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := true
	var5 := true
	var6 := (m.A0.A0.A0 == false)
	var5 = var5 && var6
	var7 := (m.A0.A0.A1 == byte(0))
	var5 = var5 && var7
	var8 := (m.A0.A0.A2 == uint16(0))
	var5 = var5 && var8
	var9 := (m.A0.A0.A3 == uint32(0))
	var5 = var5 && var9
	var10 := (m.A0.A0.A4 == uint64(0))
	var5 = var5 && var10
	var11 := (m.A0.A0.A5 == int8(0))
	var5 = var5 && var11
	var12 := (m.A0.A0.A6 == int16(0))
	var5 = var5 && var12
	var13 := (m.A0.A0.A7 == int32(0))
	var5 = var5 && var13
	var14 := (m.A0.A0.A8 == int64(0))
	var5 = var5 && var14
	var15 := (m.A0.A0.A9 == float32(0))
	var5 = var5 && var15
	var16 := (m.A0.A0.A10 == float64(0))
	var5 = var5 && var16
	var17 := (m.A0.A0.A11 == "")
	var5 = var5 && var17
	var18 := (m.A0.A0.A12 == (error)(nil))
	var5 = var5 && var18
	var19 := m.A0.A0.A13 == nil || m.A0.A0.A13.IsNilAny()
	var5 = var5 && var19
	var20 := (m.A0.A0.A14 == nil || m.A0.A0.A14 == vdl.AnyType)
	var5 = var5 && var20
	var21 := (m.A0.A0.B0 == NamedBool(false))
	var5 = var5 && var21
	var22 := (m.A0.A0.B1 == NamedByte(0))
	var5 = var5 && var22
	var23 := (m.A0.A0.B2 == NamedUint16(0))
	var5 = var5 && var23
	var24 := (m.A0.A0.B3 == NamedUint32(0))
	var5 = var5 && var24
	var25 := (m.A0.A0.B4 == NamedUint64(0))
	var5 = var5 && var25
	var26 := (m.A0.A0.B5 == NamedInt8(0))
	var5 = var5 && var26
	var27 := (m.A0.A0.B6 == NamedInt16(0))
	var5 = var5 && var27
	var28 := (m.A0.A0.B7 == NamedInt32(0))
	var5 = var5 && var28
	var29 := (m.A0.A0.B8 == NamedInt64(0))
	var5 = var5 && var29
	var30 := (m.A0.A0.B9 == NamedFloat32(0))
	var5 = var5 && var30
	var31 := (m.A0.A0.B10 == NamedFloat64(0))
	var5 = var5 && var31
	var32 := (m.A0.A0.B11 == NamedString(""))
	var5 = var5 && var32
	var33 := (m.A0.A0.B12 == NamedEnumA)
	var5 = var5 && var33
	var var34 bool
	if field, ok := m.A0.A0.B13.(NamedUnionA); ok {

		var35 := (field.Value == false)
		var34 = var35
	}
	var5 = var5 && var34
	var4 = var4 && var5
	var36 := true
	for _, elem37 := range m.A0.A1 {

		var38 := true
		var39 := (elem37.A0 == false)
		var38 = var38 && var39
		var40 := (elem37.A1 == byte(0))
		var38 = var38 && var40
		var41 := (elem37.A2 == uint16(0))
		var38 = var38 && var41
		var42 := (elem37.A3 == uint32(0))
		var38 = var38 && var42
		var43 := (elem37.A4 == uint64(0))
		var38 = var38 && var43
		var44 := (elem37.A5 == int8(0))
		var38 = var38 && var44
		var45 := (elem37.A6 == int16(0))
		var38 = var38 && var45
		var46 := (elem37.A7 == int32(0))
		var38 = var38 && var46
		var47 := (elem37.A8 == int64(0))
		var38 = var38 && var47
		var48 := (elem37.A9 == float32(0))
		var38 = var38 && var48
		var49 := (elem37.A10 == float64(0))
		var38 = var38 && var49
		var50 := (elem37.A11 == "")
		var38 = var38 && var50
		var51 := (elem37.A12 == (error)(nil))
		var38 = var38 && var51
		var52 := elem37.A13 == nil || elem37.A13.IsNilAny()
		var38 = var38 && var52
		var53 := (elem37.A14 == nil || elem37.A14 == vdl.AnyType)
		var38 = var38 && var53
		var54 := (elem37.B0 == NamedBool(false))
		var38 = var38 && var54
		var55 := (elem37.B1 == NamedByte(0))
		var38 = var38 && var55
		var56 := (elem37.B2 == NamedUint16(0))
		var38 = var38 && var56
		var57 := (elem37.B3 == NamedUint32(0))
		var38 = var38 && var57
		var58 := (elem37.B4 == NamedUint64(0))
		var38 = var38 && var58
		var59 := (elem37.B5 == NamedInt8(0))
		var38 = var38 && var59
		var60 := (elem37.B6 == NamedInt16(0))
		var38 = var38 && var60
		var61 := (elem37.B7 == NamedInt32(0))
		var38 = var38 && var61
		var62 := (elem37.B8 == NamedInt64(0))
		var38 = var38 && var62
		var63 := (elem37.B9 == NamedFloat32(0))
		var38 = var38 && var63
		var64 := (elem37.B10 == NamedFloat64(0))
		var38 = var38 && var64
		var65 := (elem37.B11 == NamedString(""))
		var38 = var38 && var65
		var66 := (elem37.B12 == NamedEnumA)
		var38 = var38 && var66
		var var67 bool
		if field, ok := elem37.B13.(NamedUnionA); ok {

			var68 := (field.Value == false)
			var67 = var68
		}
		var38 = var38 && var67
		if !var38 {
			var36 = false
			break
		}
	}
	var4 = var4 && var36
	var var69 bool
	if len(m.A0.A2) == 0 {
		var69 = true
	}
	var4 = var4 && var69
	var var70 bool
	if len(m.A0.A3) == 0 {
		var70 = true
	}
	var4 = var4 && var70
	var var71 bool
	if len(m.A0.A4) == 0 {
		var71 = true
	}
	var4 = var4 && var71
	if var4 {
		if err := fieldsTarget1.ZeroField("A0"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A0")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.A0.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var74 := true
	for _, elem75 := range m.A1 {

		var76 := true
		var77 := true
		var78 := (elem75.A0.A0 == false)
		var77 = var77 && var78
		var79 := (elem75.A0.A1 == byte(0))
		var77 = var77 && var79
		var80 := (elem75.A0.A2 == uint16(0))
		var77 = var77 && var80
		var81 := (elem75.A0.A3 == uint32(0))
		var77 = var77 && var81
		var82 := (elem75.A0.A4 == uint64(0))
		var77 = var77 && var82
		var83 := (elem75.A0.A5 == int8(0))
		var77 = var77 && var83
		var84 := (elem75.A0.A6 == int16(0))
		var77 = var77 && var84
		var85 := (elem75.A0.A7 == int32(0))
		var77 = var77 && var85
		var86 := (elem75.A0.A8 == int64(0))
		var77 = var77 && var86
		var87 := (elem75.A0.A9 == float32(0))
		var77 = var77 && var87
		var88 := (elem75.A0.A10 == float64(0))
		var77 = var77 && var88
		var89 := (elem75.A0.A11 == "")
		var77 = var77 && var89
		var90 := (elem75.A0.A12 == (error)(nil))
		var77 = var77 && var90
		var91 := elem75.A0.A13 == nil || elem75.A0.A13.IsNilAny()
		var77 = var77 && var91
		var92 := (elem75.A0.A14 == nil || elem75.A0.A14 == vdl.AnyType)
		var77 = var77 && var92
		var93 := (elem75.A0.B0 == NamedBool(false))
		var77 = var77 && var93
		var94 := (elem75.A0.B1 == NamedByte(0))
		var77 = var77 && var94
		var95 := (elem75.A0.B2 == NamedUint16(0))
		var77 = var77 && var95
		var96 := (elem75.A0.B3 == NamedUint32(0))
		var77 = var77 && var96
		var97 := (elem75.A0.B4 == NamedUint64(0))
		var77 = var77 && var97
		var98 := (elem75.A0.B5 == NamedInt8(0))
		var77 = var77 && var98
		var99 := (elem75.A0.B6 == NamedInt16(0))
		var77 = var77 && var99
		var100 := (elem75.A0.B7 == NamedInt32(0))
		var77 = var77 && var100
		var101 := (elem75.A0.B8 == NamedInt64(0))
		var77 = var77 && var101
		var102 := (elem75.A0.B9 == NamedFloat32(0))
		var77 = var77 && var102
		var103 := (elem75.A0.B10 == NamedFloat64(0))
		var77 = var77 && var103
		var104 := (elem75.A0.B11 == NamedString(""))
		var77 = var77 && var104
		var105 := (elem75.A0.B12 == NamedEnumA)
		var77 = var77 && var105
		var var106 bool
		if field, ok := elem75.A0.B13.(NamedUnionA); ok {

			var107 := (field.Value == false)
			var106 = var107
		}
		var77 = var77 && var106
		var76 = var76 && var77
		var108 := true
		for _, elem109 := range elem75.A1 {

			var110 := true
			var111 := (elem109.A0 == false)
			var110 = var110 && var111
			var112 := (elem109.A1 == byte(0))
			var110 = var110 && var112
			var113 := (elem109.A2 == uint16(0))
			var110 = var110 && var113
			var114 := (elem109.A3 == uint32(0))
			var110 = var110 && var114
			var115 := (elem109.A4 == uint64(0))
			var110 = var110 && var115
			var116 := (elem109.A5 == int8(0))
			var110 = var110 && var116
			var117 := (elem109.A6 == int16(0))
			var110 = var110 && var117
			var118 := (elem109.A7 == int32(0))
			var110 = var110 && var118
			var119 := (elem109.A8 == int64(0))
			var110 = var110 && var119
			var120 := (elem109.A9 == float32(0))
			var110 = var110 && var120
			var121 := (elem109.A10 == float64(0))
			var110 = var110 && var121
			var122 := (elem109.A11 == "")
			var110 = var110 && var122
			var123 := (elem109.A12 == (error)(nil))
			var110 = var110 && var123
			var124 := elem109.A13 == nil || elem109.A13.IsNilAny()
			var110 = var110 && var124
			var125 := (elem109.A14 == nil || elem109.A14 == vdl.AnyType)
			var110 = var110 && var125
			var126 := (elem109.B0 == NamedBool(false))
			var110 = var110 && var126
			var127 := (elem109.B1 == NamedByte(0))
			var110 = var110 && var127
			var128 := (elem109.B2 == NamedUint16(0))
			var110 = var110 && var128
			var129 := (elem109.B3 == NamedUint32(0))
			var110 = var110 && var129
			var130 := (elem109.B4 == NamedUint64(0))
			var110 = var110 && var130
			var131 := (elem109.B5 == NamedInt8(0))
			var110 = var110 && var131
			var132 := (elem109.B6 == NamedInt16(0))
			var110 = var110 && var132
			var133 := (elem109.B7 == NamedInt32(0))
			var110 = var110 && var133
			var134 := (elem109.B8 == NamedInt64(0))
			var110 = var110 && var134
			var135 := (elem109.B9 == NamedFloat32(0))
			var110 = var110 && var135
			var136 := (elem109.B10 == NamedFloat64(0))
			var110 = var110 && var136
			var137 := (elem109.B11 == NamedString(""))
			var110 = var110 && var137
			var138 := (elem109.B12 == NamedEnumA)
			var110 = var110 && var138
			var var139 bool
			if field, ok := elem109.B13.(NamedUnionA); ok {

				var140 := (field.Value == false)
				var139 = var140
			}
			var110 = var110 && var139
			if !var110 {
				var108 = false
				break
			}
		}
		var76 = var76 && var108
		var var141 bool
		if len(elem75.A2) == 0 {
			var141 = true
		}
		var76 = var76 && var141
		var var142 bool
		if len(elem75.A3) == 0 {
			var142 = true
		}
		var76 = var76 && var142
		var var143 bool
		if len(elem75.A4) == 0 {
			var143 = true
		}
		var76 = var76 && var143
		if !var76 {
			var74 = false
			break
		}
	}
	if var74 {
		if err := fieldsTarget1.ZeroField("A1"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget72, fieldTarget73, err := fieldsTarget1.StartField("A1")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.A1.FillVDLTarget(fieldTarget73, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget72, fieldTarget73); err != nil {
				return err
			}
		}
	}
	var var146 bool
	if len(m.A2) == 0 {
		var146 = true
	}
	if var146 {
		if err := fieldsTarget1.ZeroField("A2"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget144, fieldTarget145, err := fieldsTarget1.StartField("A2")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget147, err := fieldTarget145.StartList(tt.NonOptional().Field(2).Type, len(m.A2))
			if err != nil {
				return err
			}
			for i, elem149 := range m.A2 {
				elemTarget148, err := listTarget147.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem149.FillVDLTarget(elemTarget148, tt.NonOptional().Field(2).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget147.FinishElem(elemTarget148); err != nil {
					return err
				}
			}
			if err := fieldTarget145.FinishList(listTarget147); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget144, fieldTarget145); err != nil {
				return err
			}
		}
	}
	var var152 bool
	if len(m.A3) == 0 {
		var152 = true
	}
	if var152 {
		if err := fieldsTarget1.ZeroField("A3"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget150, fieldTarget151, err := fieldsTarget1.StartField("A3")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget153, err := fieldTarget151.StartMap(tt.NonOptional().Field(3).Type, len(m.A3))
			if err != nil {
				return err
			}
			for key155, value157 := range m.A3 {
				keyTarget154, err := mapTarget153.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget154.FromString(string(key155), tt.NonOptional().Field(3).Type.Key()); err != nil {
					return err
				}
				valueTarget156, err := mapTarget153.FinishKeyStartField(keyTarget154)
				if err != nil {
					return err
				}

				if err := value157.FillVDLTarget(valueTarget156, tt.NonOptional().Field(3).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget153.FinishField(keyTarget154, valueTarget156); err != nil {
					return err
				}
			}
			if err := fieldTarget151.FinishMap(mapTarget153); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget150, fieldTarget151); err != nil {
				return err
			}
		}
	}
	var var160 bool
	if len(m.A4) == 0 {
		var160 = true
	}
	if var160 {
		if err := fieldsTarget1.ZeroField("A4"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget158, fieldTarget159, err := fieldsTarget1.StartField("A4")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget161, err := fieldTarget159.StartMap(tt.NonOptional().Field(4).Type, len(m.A4))
			if err != nil {
				return err
			}
			for key163, value165 := range m.A4 {
				keyTarget162, err := mapTarget161.StartKey()
				if err != nil {
					return err
				}

				if err := key163.FillVDLTarget(keyTarget162, tt.NonOptional().Field(4).Type.Key()); err != nil {
					return err
				}
				valueTarget164, err := mapTarget161.FinishKeyStartField(keyTarget162)
				if err != nil {
					return err
				}

				listTarget166, err := valueTarget164.StartList(tt.NonOptional().Field(4).Type.Elem(), len(value165))
				if err != nil {
					return err
				}
				for i, elem168 := range value165 {
					elemTarget167, err := listTarget166.StartElem(i)
					if err != nil {
						return err
					}

					mapTarget169, err := elemTarget167.StartMap(tt.NonOptional().Field(4).Type.Elem().Elem(), len(elem168))
					if err != nil {
						return err
					}
					for key171, value173 := range elem168 {
						keyTarget170, err := mapTarget169.StartKey()
						if err != nil {
							return err
						}
						if err := keyTarget170.FromString(string(key171), tt.NonOptional().Field(4).Type.Elem().Elem().Key()); err != nil {
							return err
						}
						valueTarget172, err := mapTarget169.FinishKeyStartField(keyTarget170)
						if err != nil {
							return err
						}

						if err := value173.FillVDLTarget(valueTarget172, tt.NonOptional().Field(4).Type.Elem().Elem().Elem()); err != nil {
							return err
						}
						if err := mapTarget169.FinishField(keyTarget170, valueTarget172); err != nil {
							return err
						}
					}
					if err := elemTarget167.FinishMap(mapTarget169); err != nil {
						return err
					}
					if err := listTarget166.FinishElem(elemTarget167); err != nil {
						return err
					}
				}
				if err := valueTarget164.FinishList(listTarget166); err != nil {
					return err
				}
				if err := mapTarget161.FinishField(keyTarget162, valueTarget164); err != nil {
					return err
				}
			}
			if err := fieldTarget159.FinishMap(mapTarget161); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget158, fieldTarget159); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *CompComp) MakeVDLTarget() vdl.Target {
	return &CompCompTarget{Value: m}
}

type CompCompTarget struct {
	Value    *CompComp
	a0Target CompositesTarget
	a1Target CompositesArrayTarget
	a2Target __VDLTarget4_list
	a3Target __VDLTarget5_map
	a4Target __VDLTarget6_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CompCompTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*CompComp)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CompCompTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A0":
		t.a0Target.Value = &t.Value.A0
		target, err := &t.a0Target, error(nil)
		return nil, target, err
	case "A1":
		t.a1Target.Value = &t.Value.A1
		target, err := &t.a1Target, error(nil)
		return nil, target, err
	case "A2":
		t.a2Target.Value = &t.Value.A2
		target, err := &t.a2Target, error(nil)
		return nil, target, err
	case "A3":
		t.a3Target.Value = &t.Value.A3
		target, err := &t.a3Target, error(nil)
		return nil, target, err
	case "A4":
		t.a4Target.Value = &t.Value.A4
		target, err := &t.a4Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.CompComp", name)
	}
}
func (t *CompCompTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CompCompTarget) ZeroField(name string) error {
	switch name {
	case "A0":
		t.Value.A0 = Composites{
			A0: Scalars{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
			A1: ScalarsArray{
				{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
				{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
			},
		}
		return nil
	case "A1":
		t.Value.A1 = CompositesArray{
			{
				A0: Scalars{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
				A1: ScalarsArray{
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
				},
			},
			{
				A0: Scalars{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
				A1: ScalarsArray{
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
				},
			},
		}
		return nil
	case "A2":
		t.Value.A2 = []Composites(nil)
		return nil
	case "A3":
		t.Value.A3 = map[string]Composites(nil)
		return nil
	case "A4":
		t.Value.A4 = map[KeyScalars][]map[string]Composites(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.CompComp", name)
	}
}
func (t *CompCompTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []Composites
type __VDLTarget4_list struct {
	Value      *[]Composites
	elemTarget CompositesTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget4_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Composites)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Composites, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget4_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget4_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// map[string]Composites
type __VDLTarget5_map struct {
	Value      *map[string]Composites
	currKey    string
	currElem   Composites
	keyTarget  vdl.StringTarget
	elemTarget CompositesTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget5_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]Composites)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]Composites)
	return t, nil
}
func (t *__VDLTarget5_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = Composites{
		A0: Scalars{
			A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
			A14: vdl.AnyType,
			B13: NamedUnionA{},
		},
		A1: ScalarsArray{
			{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
			{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
		},
	}
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget5_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[KeyScalars][]map[string]Composites
type __VDLTarget6_map struct {
	Value      *map[KeyScalars][]map[string]Composites
	currKey    KeyScalars
	currElem   []map[string]Composites
	keyTarget  KeyScalarsTarget
	elemTarget __VDLTarget7_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget6_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[KeyScalars][]map[string]Composites)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[KeyScalars][]map[string]Composites)
	return t, nil
}
func (t *__VDLTarget6_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = KeyScalars{}
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget6_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []map[string]Composites(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget6_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget6_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []map[string]Composites
type __VDLTarget7_list struct {
	Value      *[]map[string]Composites
	elemTarget __VDLTarget5_map
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget7_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]map[string]Composites)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]map[string]Composites, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget7_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget7_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget7_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x *CompComp) VDLRead(dec vdl.Decoder) error {
	*x = CompComp{
		A0: Composites{
			A0: Scalars{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
			A1: ScalarsArray{
				{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
				{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
			},
		},
		A1: CompositesArray{
			{
				A0: Scalars{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
				A1: ScalarsArray{
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
				},
			},
			{
				A0: Scalars{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
				A1: ScalarsArray{
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
				},
			},
		},
	}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "A0":
			match++
			if err = x.A0.VDLRead(dec); err != nil {
				return err
			}
		case "A1":
			match++
			if err = x.A1.VDLRead(dec); err != nil {
				return err
			}
		case "A2":
			match++
			if err = __VDLRead4_list(dec, &x.A2); err != nil {
				return err
			}
		case "A3":
			match++
			if err = __VDLRead5_map(dec, &x.A3); err != nil {
				return err
			}
		case "A4":
			match++
			if err = __VDLRead6_map(dec, &x.A4); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead4_list(dec vdl.Decoder, x *[]Composites) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
	case len > 0:
		*x = make([]Composites, 0, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Composites
		if err = elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLRead5_map(dec vdl.Decoder, x *map[string]Composites) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
		return dec.FinishValue()
	case len > 0:
		*x = make(map[string]Composites, len)
	default:
		*x = make(map[string]Composites)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var key string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem Composites
		{
			if err = elem.VDLRead(dec); err != nil {
				return err
			}
		}
		(*x)[key] = elem
	}
}

func __VDLRead6_map(dec vdl.Decoder, x *map[KeyScalars][]map[string]Composites) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
		return dec.FinishValue()
	case len > 0:
		*x = make(map[KeyScalars][]map[string]Composites, len)
	default:
		*x = make(map[KeyScalars][]map[string]Composites)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var key KeyScalars
		{
			if err = key.VDLRead(dec); err != nil {
				return err
			}
		}
		var elem []map[string]Composites
		{
			if err = __VDLRead7_list(dec, &elem); err != nil {
				return err
			}
		}
		(*x)[key] = elem
	}
}

func __VDLRead7_list(dec vdl.Decoder, x *[]map[string]Composites) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
	case len > 0:
		*x = make([]map[string]Composites, 0, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem map[string]Composites
		if err = __VDLRead5_map(dec, &elem); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// Args will be reordered to show up before NestedArgs in the generated output.
type Args struct {
	A int32
	B int32
}

func (Args) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.Args"`
}) {
}

func (m *Args) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A == int32(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromInt(int64(m.A), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.B == int32(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromInt(int64(m.B), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Args) MakeVDLTarget() vdl.Target {
	return &ArgsTarget{Value: m}
}

type ArgsTarget struct {
	Value   *Args
	aTarget vdl.Int32Target
	bTarget vdl.Int32Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ArgsTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Args)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ArgsTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.Args", name)
	}
}
func (t *ArgsTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ArgsTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = int32(0)
		return nil
	case "B":
		t.Value.B = int32(0)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.Args", name)
	}
}
func (t *ArgsTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *Args) VDLRead(dec vdl.Decoder) error {
	*x = Args{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "A":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.A = int32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "B":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.B = int32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// NestedArgs is defined before Args; that's allowed in regular Go, and also
// allowed in our vdl files.  The compiler will re-order dependent types to ease
// code generation in other languages.
type NestedArgs struct {
	Args Args
}

func (NestedArgs) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NestedArgs"`
}) {
}

func (m *NestedArgs) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Args == Args{})
	if var4 {
		if err := fieldsTarget1.ZeroField("Args"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Args")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Args.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NestedArgs) MakeVDLTarget() vdl.Target {
	return &NestedArgsTarget{Value: m}
}

type NestedArgsTarget struct {
	Value      *NestedArgs
	argsTarget ArgsTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NestedArgsTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*NestedArgs)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *NestedArgsTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Args":
		t.argsTarget.Value = &t.Value.Args
		target, err := &t.argsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.NestedArgs", name)
	}
}
func (t *NestedArgsTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *NestedArgsTarget) ZeroField(name string) error {
	switch name {
	case "Args":
		t.Value.Args = Args{}
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/lib/vdl/testdata/base.NestedArgs", name)
	}
}
func (t *NestedArgsTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *NestedArgs) VDLRead(dec vdl.Decoder) error {
	*x = NestedArgs{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Args":
			match++
			if err = x.Args.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

//////////////////////////////////////////////////
// Const definitions

const Cbool = true
const Cbyte = byte(1)
const Cint32 = int32(2)
const Cint64 = int64(3)
const Cuint32 = uint32(4)
const Cuint64 = uint64(5)
const Cfloat32 = float32(6)
const Cfloat64 = float64(7)
const CNamedBool = NamedBool(true)

var CNamedStruct = NamedStruct{
	A: true,
	B: "test",
}

const Cstring = "foo"
const Cenum = NamedEnumA

var Cunion = NamedUnion(NamedUnionA{true})
var Carray = NamedArray{
	true,
	false,
}
var Clist = []int32{
	1,
	2,
	3,
}
var Cset = map[int32]struct{}{
	1: struct{}{},
	2: struct{}{},
	3: struct{}{},
}
var cmap = map[int32]string{
	1: "A",
	2: "B",
	3: "C",
}
var Cargs = Args{
	A: 1,
	B: 2,
}
var CScalars = Scalars{
	A0:  true,
	A1:  1,
	A2:  2,
	A3:  3,
	A4:  4,
	A5:  5,
	A6:  6,
	A7:  7,
	A8:  8,
	A9:  9,
	A10: 10,
	A11: "abc",
	A13: vom.RawBytesOf(false),
	A14: vdl.TypeOf((*bool)(nil)),
	B0:  true,
	B1:  1,
	B2:  2,
	B3:  3,
	B4:  4,
	B5:  5,
	B6:  6,
	B7:  7,
	B8:  8,
	B9:  9,
	B10: 10,
	B11: "abc",
	B12: NamedEnumB,
	B13: NamedUnionC{123},
}

const True = true
const Foo = "foo"
const Five = int32(5)
const Six = uint64(6)
const SixSquared = uint64(36)
const FiveSquared = int32(25)

var CTypeObject_bool = vdl.TypeOf((*bool)(nil))
var CTypeObject_string = vdl.TypeOf((*string)(nil))
var CTypeObject_bytes = vdl.TypeOf((*[]byte)(nil))
var CTypeObject_byte = vdl.TypeOf((*byte)(nil))
var CTypeObject_uint16 = vdl.TypeOf((*uint16)(nil))
var CTypeObject_int8 = vdl.TypeOf((*int8)(nil))
var CTypeObject_int16 = vdl.TypeOf((*int16)(nil))
var CTypeObject_float32 = vdl.TypeOf((*float32)(nil))
var CTypeObject_enum = vdl.TypeOf((*NamedEnum)(nil))
var CTypeObject_Array = vdl.TypeOf((*NamedArray)(nil))
var CTypeObject_List = vdl.TypeOf((*[]string)(nil))
var CTypeObject_Set = vdl.TypeOf((*map[string]struct{})(nil))
var CTypeObject_Map = vdl.TypeOf((*map[string]int64)(nil))
var CTypeObject_Struct = vdl.TypeOf((*Scalars)(nil)).Elem()
var CTypeObject_Union = vdl.TypeOf((*NamedUnion)(nil))
var CTypeObject_TypeObject = vdl.TypeObjectType
var CTypeObject_Any = vdl.AnyType

//////////////////////////////////////////////////
// Error definitions
var (
	ErrNoParams1   = verror.Register("v.io/x/ref/lib/vdl/testdata/base.NoParams1", verror.NoRetry, "{1:}{2:} en msg")
	ErrNoParams2   = verror.Register("v.io/x/ref/lib/vdl/testdata/base.NoParams2", verror.RetryRefetch, "{1:}{2:} en msg")
	ErrWithParams1 = verror.Register("v.io/x/ref/lib/vdl/testdata/base.WithParams1", verror.NoRetry, "{1:}{2:} en x={3} y={4}")
	ErrWithParams2 = verror.Register("v.io/x/ref/lib/vdl/testdata/base.WithParams2", verror.RetryRefetch, "{1:}{2:} en x={3} y={4}")
	errNotExported = verror.Register("v.io/x/ref/lib/vdl/testdata/base.notExported", verror.NoRetry, "{1:}{2:} en x={3} y={4}")
)

// NewErrNoParams1 returns an error with the ErrNoParams1 ID.
func NewErrNoParams1(ctx *context.T) error {
	return verror.New(ErrNoParams1, ctx)
}

// NewErrNoParams2 returns an error with the ErrNoParams2 ID.
func NewErrNoParams2(ctx *context.T) error {
	return verror.New(ErrNoParams2, ctx)
}

// NewErrWithParams1 returns an error with the ErrWithParams1 ID.
func NewErrWithParams1(ctx *context.T, x string, y int32) error {
	return verror.New(ErrWithParams1, ctx, x, y)
}

// NewErrWithParams2 returns an error with the ErrWithParams2 ID.
func NewErrWithParams2(ctx *context.T, x string, y int32) error {
	return verror.New(ErrWithParams2, ctx, x, y)
}

// newErrNotExported returns an error with the errNotExported ID.
func newErrNotExported(ctx *context.T, x string, y int32) error {
	return verror.New(errNotExported, ctx, x, y)
}

//////////////////////////////////////////////////
// Interface definitions

// ServiceAClientMethods is the client interface
// containing ServiceA methods.
type ServiceAClientMethods interface {
	MethodA1(*context.T, ...rpc.CallOpt) error
	MethodA2(_ *context.T, a int32, b string, _ ...rpc.CallOpt) (s string, _ error)
	MethodA3(_ *context.T, a int32, _ ...rpc.CallOpt) (ServiceAMethodA3ClientCall, error)
	MethodA4(_ *context.T, a int32, _ ...rpc.CallOpt) (ServiceAMethodA4ClientCall, error)
}

// ServiceAClientStub adds universal methods to ServiceAClientMethods.
type ServiceAClientStub interface {
	ServiceAClientMethods
	rpc.UniversalServiceMethods
}

// ServiceAClient returns a client stub for ServiceA.
func ServiceAClient(name string) ServiceAClientStub {
	return implServiceAClientStub{name}
}

type implServiceAClientStub struct {
	name string
}

func (c implServiceAClientStub) MethodA1(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "MethodA1", nil, nil, opts...)
	return
}

func (c implServiceAClientStub) MethodA2(ctx *context.T, i0 int32, i1 string, opts ...rpc.CallOpt) (o0 string, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "MethodA2", []interface{}{i0, i1}, []interface{}{&o0}, opts...)
	return
}

func (c implServiceAClientStub) MethodA3(ctx *context.T, i0 int32, opts ...rpc.CallOpt) (ocall ServiceAMethodA3ClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "MethodA3", []interface{}{i0}, opts...); err != nil {
		return
	}
	ocall = &implServiceAMethodA3ClientCall{ClientCall: call}
	return
}

func (c implServiceAClientStub) MethodA4(ctx *context.T, i0 int32, opts ...rpc.CallOpt) (ocall ServiceAMethodA4ClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "MethodA4", []interface{}{i0}, opts...); err != nil {
		return
	}
	ocall = &implServiceAMethodA4ClientCall{ClientCall: call}
	return
}

// ServiceAMethodA3ClientStream is the client stream for ServiceA.MethodA3.
type ServiceAMethodA3ClientStream interface {
	// RecvStream returns the receiver side of the ServiceA.MethodA3 client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() Scalars
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// ServiceAMethodA3ClientCall represents the call returned from ServiceA.MethodA3.
type ServiceAMethodA3ClientCall interface {
	ServiceAMethodA3ClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() (s string, _ error)
}

type implServiceAMethodA3ClientCall struct {
	rpc.ClientCall
	valRecv Scalars
	errRecv error
}

func (c *implServiceAMethodA3ClientCall) RecvStream() interface {
	Advance() bool
	Value() Scalars
	Err() error
} {
	return implServiceAMethodA3ClientCallRecv{c}
}

type implServiceAMethodA3ClientCallRecv struct {
	c *implServiceAMethodA3ClientCall
}

func (c implServiceAMethodA3ClientCallRecv) Advance() bool {
	c.c.valRecv = Scalars{}
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implServiceAMethodA3ClientCallRecv) Value() Scalars {
	return c.c.valRecv
}
func (c implServiceAMethodA3ClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implServiceAMethodA3ClientCall) Finish() (o0 string, err error) {
	err = c.ClientCall.Finish(&o0)
	return
}

// ServiceAMethodA4ClientStream is the client stream for ServiceA.MethodA4.
type ServiceAMethodA4ClientStream interface {
	// RecvStream returns the receiver side of the ServiceA.MethodA4 client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() string
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the ServiceA.MethodA4 client stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors
		// encountered while sending, or if Send is called after Close or
		// the stream has been canceled.  Blocks if there is no buffer
		// space; will unblock when buffer space is available or after
		// the stream has been canceled.
		Send(item int32) error
		// Close indicates to the server that no more items will be sent;
		// server Recv calls will receive io.EOF after all sent items.
		// This is an optional call - e.g. a client might call Close if it
		// needs to continue receiving items from the server after it's
		// done sending.  Returns errors encountered while closing, or if
		// Close is called after the stream has been canceled.  Like Send,
		// blocks if there is no buffer space available.
		Close() error
	}
}

// ServiceAMethodA4ClientCall represents the call returned from ServiceA.MethodA4.
type ServiceAMethodA4ClientCall interface {
	ServiceAMethodA4ClientStream
	// Finish performs the equivalent of SendStream().Close, then blocks until
	// the server is done, and returns the positional return values for the call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implServiceAMethodA4ClientCall struct {
	rpc.ClientCall
	valRecv string
	errRecv error
}

func (c *implServiceAMethodA4ClientCall) RecvStream() interface {
	Advance() bool
	Value() string
	Err() error
} {
	return implServiceAMethodA4ClientCallRecv{c}
}

type implServiceAMethodA4ClientCallRecv struct {
	c *implServiceAMethodA4ClientCall
}

func (c implServiceAMethodA4ClientCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implServiceAMethodA4ClientCallRecv) Value() string {
	return c.c.valRecv
}
func (c implServiceAMethodA4ClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implServiceAMethodA4ClientCall) SendStream() interface {
	Send(item int32) error
	Close() error
} {
	return implServiceAMethodA4ClientCallSend{c}
}

type implServiceAMethodA4ClientCallSend struct {
	c *implServiceAMethodA4ClientCall
}

func (c implServiceAMethodA4ClientCallSend) Send(item int32) error {
	return c.c.Send(item)
}
func (c implServiceAMethodA4ClientCallSend) Close() error {
	return c.c.CloseSend()
}
func (c *implServiceAMethodA4ClientCall) Finish() (err error) {
	err = c.ClientCall.Finish()
	return
}

// ServiceAServerMethods is the interface a server writer
// implements for ServiceA.
type ServiceAServerMethods interface {
	MethodA1(*context.T, rpc.ServerCall) error
	MethodA2(_ *context.T, _ rpc.ServerCall, a int32, b string) (s string, _ error)
	MethodA3(_ *context.T, _ ServiceAMethodA3ServerCall, a int32) (s string, _ error)
	MethodA4(_ *context.T, _ ServiceAMethodA4ServerCall, a int32) error
}

// ServiceAServerStubMethods is the server interface containing
// ServiceA methods, as expected by rpc.Server.
// The only difference between this interface and ServiceAServerMethods
// is the streaming methods.
type ServiceAServerStubMethods interface {
	MethodA1(*context.T, rpc.ServerCall) error
	MethodA2(_ *context.T, _ rpc.ServerCall, a int32, b string) (s string, _ error)
	MethodA3(_ *context.T, _ *ServiceAMethodA3ServerCallStub, a int32) (s string, _ error)
	MethodA4(_ *context.T, _ *ServiceAMethodA4ServerCallStub, a int32) error
}

// ServiceAServerStub adds universal methods to ServiceAServerStubMethods.
type ServiceAServerStub interface {
	ServiceAServerStubMethods
	// Describe the ServiceA interfaces.
	Describe__() []rpc.InterfaceDesc
}

// ServiceAServer returns a server stub for ServiceA.
// It converts an implementation of ServiceAServerMethods into
// an object that may be used by rpc.Server.
func ServiceAServer(impl ServiceAServerMethods) ServiceAServerStub {
	stub := implServiceAServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implServiceAServerStub struct {
	impl ServiceAServerMethods
	gs   *rpc.GlobState
}

func (s implServiceAServerStub) MethodA1(ctx *context.T, call rpc.ServerCall) error {
	return s.impl.MethodA1(ctx, call)
}

func (s implServiceAServerStub) MethodA2(ctx *context.T, call rpc.ServerCall, i0 int32, i1 string) (string, error) {
	return s.impl.MethodA2(ctx, call, i0, i1)
}

func (s implServiceAServerStub) MethodA3(ctx *context.T, call *ServiceAMethodA3ServerCallStub, i0 int32) (string, error) {
	return s.impl.MethodA3(ctx, call, i0)
}

func (s implServiceAServerStub) MethodA4(ctx *context.T, call *ServiceAMethodA4ServerCallStub, i0 int32) error {
	return s.impl.MethodA4(ctx, call, i0)
}

func (s implServiceAServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implServiceAServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{ServiceADesc}
}

// ServiceADesc describes the ServiceA interface.
var ServiceADesc rpc.InterfaceDesc = descServiceA

// descServiceA hides the desc to keep godoc clean.
var descServiceA = rpc.InterfaceDesc{
	Name:    "ServiceA",
	PkgPath: "v.io/x/ref/lib/vdl/testdata/base",
	Methods: []rpc.MethodDesc{
		{
			Name: "MethodA1",
		},
		{
			Name: "MethodA2",
			InArgs: []rpc.ArgDesc{
				{"a", ``}, // int32
				{"b", ``}, // string
			},
			OutArgs: []rpc.ArgDesc{
				{"s", ``}, // string
			},
		},
		{
			Name: "MethodA3",
			InArgs: []rpc.ArgDesc{
				{"a", ``}, // int32
			},
			OutArgs: []rpc.ArgDesc{
				{"s", ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf("tag"), vdl.ValueOf(uint64(6))},
		},
		{
			Name: "MethodA4",
			InArgs: []rpc.ArgDesc{
				{"a", ``}, // int32
			},
		},
	},
}

// ServiceAMethodA3ServerStream is the server stream for ServiceA.MethodA3.
type ServiceAMethodA3ServerStream interface {
	// SendStream returns the send side of the ServiceA.MethodA3 server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item Scalars) error
	}
}

// ServiceAMethodA3ServerCall represents the context passed to ServiceA.MethodA3.
type ServiceAMethodA3ServerCall interface {
	rpc.ServerCall
	ServiceAMethodA3ServerStream
}

// ServiceAMethodA3ServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements ServiceAMethodA3ServerCall.
type ServiceAMethodA3ServerCallStub struct {
	rpc.StreamServerCall
}

// Init initializes ServiceAMethodA3ServerCallStub from rpc.StreamServerCall.
func (s *ServiceAMethodA3ServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// SendStream returns the send side of the ServiceA.MethodA3 server stream.
func (s *ServiceAMethodA3ServerCallStub) SendStream() interface {
	Send(item Scalars) error
} {
	return implServiceAMethodA3ServerCallSend{s}
}

type implServiceAMethodA3ServerCallSend struct {
	s *ServiceAMethodA3ServerCallStub
}

func (s implServiceAMethodA3ServerCallSend) Send(item Scalars) error {
	return s.s.Send(item)
}

// ServiceAMethodA4ServerStream is the server stream for ServiceA.MethodA4.
type ServiceAMethodA4ServerStream interface {
	// RecvStream returns the receiver side of the ServiceA.MethodA4 server stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() int32
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the ServiceA.MethodA4 server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item string) error
	}
}

// ServiceAMethodA4ServerCall represents the context passed to ServiceA.MethodA4.
type ServiceAMethodA4ServerCall interface {
	rpc.ServerCall
	ServiceAMethodA4ServerStream
}

// ServiceAMethodA4ServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements ServiceAMethodA4ServerCall.
type ServiceAMethodA4ServerCallStub struct {
	rpc.StreamServerCall
	valRecv int32
	errRecv error
}

// Init initializes ServiceAMethodA4ServerCallStub from rpc.StreamServerCall.
func (s *ServiceAMethodA4ServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// RecvStream returns the receiver side of the ServiceA.MethodA4 server stream.
func (s *ServiceAMethodA4ServerCallStub) RecvStream() interface {
	Advance() bool
	Value() int32
	Err() error
} {
	return implServiceAMethodA4ServerCallRecv{s}
}

type implServiceAMethodA4ServerCallRecv struct {
	s *ServiceAMethodA4ServerCallStub
}

func (s implServiceAMethodA4ServerCallRecv) Advance() bool {
	s.s.errRecv = s.s.Recv(&s.s.valRecv)
	return s.s.errRecv == nil
}
func (s implServiceAMethodA4ServerCallRecv) Value() int32 {
	return s.s.valRecv
}
func (s implServiceAMethodA4ServerCallRecv) Err() error {
	if s.s.errRecv == io.EOF {
		return nil
	}
	return s.s.errRecv
}

// SendStream returns the send side of the ServiceA.MethodA4 server stream.
func (s *ServiceAMethodA4ServerCallStub) SendStream() interface {
	Send(item string) error
} {
	return implServiceAMethodA4ServerCallSend{s}
}

type implServiceAMethodA4ServerCallSend struct {
	s *ServiceAMethodA4ServerCallStub
}

func (s implServiceAMethodA4ServerCallSend) Send(item string) error {
	return s.s.Send(item)
}

// ServiceBClientMethods is the client interface
// containing ServiceB methods.
type ServiceBClientMethods interface {
	ServiceAClientMethods
	MethodB1(_ *context.T, a Scalars, b Composites, _ ...rpc.CallOpt) (c CompComp, _ error)
}

// ServiceBClientStub adds universal methods to ServiceBClientMethods.
type ServiceBClientStub interface {
	ServiceBClientMethods
	rpc.UniversalServiceMethods
}

// ServiceBClient returns a client stub for ServiceB.
func ServiceBClient(name string) ServiceBClientStub {
	return implServiceBClientStub{name, ServiceAClient(name)}
}

type implServiceBClientStub struct {
	name string

	ServiceAClientStub
}

func (c implServiceBClientStub) MethodB1(ctx *context.T, i0 Scalars, i1 Composites, opts ...rpc.CallOpt) (o0 CompComp, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "MethodB1", []interface{}{i0, i1}, []interface{}{&o0}, opts...)
	return
}

// ServiceBServerMethods is the interface a server writer
// implements for ServiceB.
type ServiceBServerMethods interface {
	ServiceAServerMethods
	MethodB1(_ *context.T, _ rpc.ServerCall, a Scalars, b Composites) (c CompComp, _ error)
}

// ServiceBServerStubMethods is the server interface containing
// ServiceB methods, as expected by rpc.Server.
// The only difference between this interface and ServiceBServerMethods
// is the streaming methods.
type ServiceBServerStubMethods interface {
	ServiceAServerStubMethods
	MethodB1(_ *context.T, _ rpc.ServerCall, a Scalars, b Composites) (c CompComp, _ error)
}

// ServiceBServerStub adds universal methods to ServiceBServerStubMethods.
type ServiceBServerStub interface {
	ServiceBServerStubMethods
	// Describe the ServiceB interfaces.
	Describe__() []rpc.InterfaceDesc
}

// ServiceBServer returns a server stub for ServiceB.
// It converts an implementation of ServiceBServerMethods into
// an object that may be used by rpc.Server.
func ServiceBServer(impl ServiceBServerMethods) ServiceBServerStub {
	stub := implServiceBServerStub{
		impl:               impl,
		ServiceAServerStub: ServiceAServer(impl),
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implServiceBServerStub struct {
	impl ServiceBServerMethods
	ServiceAServerStub
	gs *rpc.GlobState
}

func (s implServiceBServerStub) MethodB1(ctx *context.T, call rpc.ServerCall, i0 Scalars, i1 Composites) (CompComp, error) {
	return s.impl.MethodB1(ctx, call, i0, i1)
}

func (s implServiceBServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implServiceBServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{ServiceBDesc, ServiceADesc}
}

// ServiceBDesc describes the ServiceB interface.
var ServiceBDesc rpc.InterfaceDesc = descServiceB

// descServiceB hides the desc to keep godoc clean.
var descServiceB = rpc.InterfaceDesc{
	Name:    "ServiceB",
	PkgPath: "v.io/x/ref/lib/vdl/testdata/base",
	Embeds: []rpc.EmbedDesc{
		{"ServiceA", "v.io/x/ref/lib/vdl/testdata/base", ``},
	},
	Methods: []rpc.MethodDesc{
		{
			Name: "MethodB1",
			InArgs: []rpc.ArgDesc{
				{"a", ``}, // Scalars
				{"b", ``}, // Composites
			},
			OutArgs: []rpc.ArgDesc{
				{"c", ``}, // CompComp
			},
		},
	},
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*NamedBool)(nil))
	vdl.Register((*NamedByte)(nil))
	vdl.Register((*NamedUint16)(nil))
	vdl.Register((*NamedUint32)(nil))
	vdl.Register((*NamedUint64)(nil))
	vdl.Register((*NamedInt8)(nil))
	vdl.Register((*NamedInt16)(nil))
	vdl.Register((*NamedInt32)(nil))
	vdl.Register((*NamedInt64)(nil))
	vdl.Register((*NamedFloat32)(nil))
	vdl.Register((*NamedFloat64)(nil))
	vdl.Register((*NamedString)(nil))
	vdl.Register((*NamedEnum)(nil))
	vdl.Register((*NamedArray)(nil))
	vdl.Register((*NamedList)(nil))
	vdl.Register((*NamedSet)(nil))
	vdl.Register((*NamedMap)(nil))
	vdl.Register((*NamedStruct)(nil))
	vdl.Register((*NamedUnion)(nil))
	vdl.Register((*Scalars)(nil))
	vdl.Register((*KeyScalars)(nil))
	vdl.Register((*ScalarsArray)(nil))
	vdl.Register((*Composites)(nil))
	vdl.Register((*CompositesArray)(nil))
	vdl.Register((*CompComp)(nil))
	vdl.Register((*Args)(nil))
	vdl.Register((*NestedArgs)(nil))

	// Set error format strings.
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrNoParams1.ID), "{1:}{2:} en msg")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrNoParams2.ID), "{1:}{2:} en msg")
	i18n.Cat().SetWithBase(i18n.LangID("fr"), i18n.MsgID(ErrNoParams2.ID), "{1:}{2:} fr msg")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrWithParams1.ID), "{1:}{2:} en x={3} y={4}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrWithParams2.ID), "{1:}{2:} en x={3} y={4}")
	i18n.Cat().SetWithBase(i18n.LangID("fr"), i18n.MsgID(ErrWithParams2.ID), "{1:}{2:} fr y={4} x={3}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(errNotExported.ID), "{1:}{2:} en x={3} y={4}")

	return struct{}{}
}
